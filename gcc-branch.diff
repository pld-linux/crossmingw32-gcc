Index: gcc/doc/invoke.texi
===================================================================
--- gcc/doc/invoke.texi	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/doc/invoke.texi	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -853,8 +853,8 @@
 -m5-compact  -m5-compact-nofpu @gol
 -mb  -ml  -mdalign  -mrelax @gol
 -mbigtable -mfmovd -mhitachi -mrenesas -mno-renesas -mnomacsave @gol
--mieee  -mbitops  -misize  -minline-ic_invalidate -mpadstruct  -mspace @gol
--mprefergot  -musermode -multcost=@var{number} -mdiv=@var{strategy} @gol
+-mieee -mno-ieee -mbitops  -misize  -minline-ic_invalidate -mpadstruct @gol
+-mspace -mprefergot  -musermode -multcost=@var{number} -mdiv=@var{strategy} @gol
 -mdivsi3_libfunc=@var{name} -mfixed-range=@var{register-range} @gol
 -madjust-unroll -mindexed-addressing -mgettrcost=@var{number} -mpt-fixed @gol
 -maccumulate-outgoing-args -minvalid-symbols}
@@ -16938,13 +16938,15 @@
 @option{-mhitachi} is given.
 
 @item -mieee
+@item -mno-ieee
 @opindex mieee
-Increase IEEE-compliance of floating-point code.
-At the moment, this is equivalent to @option{-fno-finite-math-only}.
-When generating 16 bit SH opcodes, getting IEEE-conforming results for
-comparisons of NANs / infinities incurs extra overhead in every
-floating point comparison, therefore the default is set to
-@option{-ffinite-math-only}.
+@opindex mnoieee
+Control the IEEE compliance of floating-point comparisons, which affects the
+handling of cases where the result of a comparison is unordered.  By default
+@option{-mieee} is implicitly enabled.  If @option{-ffinite-math-only} is
+enabled @option{-mno-ieee} is implicitly set, which results in faster
+floating-point greater-equal and less-equal comparisons.  The implcit settings
+can be overridden by specifying either @option{-mieee} or @option{-mno-ieee}.
 
 @item -minline-ic_invalidate
 @opindex minline-ic_invalidate
Index: gcc/doc/install.texi
===================================================================
--- gcc/doc/install.texi	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/doc/install.texi	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1208,7 +1208,7 @@
 
 @item --with-llsc
 On MIPS targets, make @option{-mllsc} the default when no
-@option{-mno-lsc} option is passed.  This is the default for
+@option{-mno-llsc} option is passed.  This is the default for
 Linux-based targets, as the kernel will emulate them if the ISA does
 not provide them.
 
Index: gcc/targhooks.c
===================================================================
--- gcc/targhooks.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/targhooks.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -529,6 +529,7 @@
       case scalar_to_vec:
       case cond_branch_not_taken:
       case vec_perm:
+      case vec_promote_demote:
         return 1;
 
       case unaligned_load:
Index: gcc/tree-pretty-print.c
===================================================================
--- gcc/tree-pretty-print.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/tree-pretty-print.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -805,6 +805,8 @@
 	       infer them and MEM_ATTR caching will share MEM_REFs
 	       with differently-typed op0s.  */
 	    && TREE_CODE (TREE_OPERAND (node, 0)) != INTEGER_CST
+	    /* Released SSA_NAMES have no TREE_TYPE.  */
+	    && TREE_TYPE (TREE_OPERAND (node, 0)) != NULL_TREE
 	    /* Same pointer types, but ignoring POINTER_TYPE vs.
 	       REFERENCE_TYPE.  */
 	    && (TREE_TYPE (TREE_TYPE (TREE_OPERAND (node, 0)))
@@ -1171,6 +1173,8 @@
 		     can't infer them and MEM_ATTR caching will share
 		     MEM_REFs with differently-typed op0s.  */
 		  && TREE_CODE (TREE_OPERAND (op0, 0)) != INTEGER_CST
+		  /* Released SSA_NAMES have no TREE_TYPE.  */
+		  && TREE_TYPE (TREE_OPERAND (op0, 0)) != NULL_TREE
 		  /* Same pointer types, but ignoring POINTER_TYPE vs.
 		     REFERENCE_TYPE.  */
 		  && (TREE_TYPE (TREE_TYPE (TREE_OPERAND (op0, 0)))
Index: gcc/cgraph.c
===================================================================
--- gcc/cgraph.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/cgraph.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1700,19 +1700,27 @@
   free_nodes = node;
 }
 
-/* Remove the node from cgraph.  */
+/* Remove the node from cgraph and all inline clones inlined into it.
+   Skip however removal of FORBIDDEN_NODE and return true if it needs to be
+   removed.  This allows to call the function from outer loop walking clone
+   tree.  */
 
-void
-cgraph_remove_node_and_inline_clones (struct cgraph_node *node)
+bool
+cgraph_remove_node_and_inline_clones (struct cgraph_node *node, struct cgraph_node *forbidden_node)
 {
   struct cgraph_edge *e, *next;
+  bool found = false;
+
+  if (node == forbidden_node)
+    return true;
   for (e = node->callees; e; e = next)
     {
       next = e->next_callee;
       if (!e->inline_failed)
-        cgraph_remove_node_and_inline_clones (e->callee);
+        found |= cgraph_remove_node_and_inline_clones (e->callee, forbidden_node);
     }
   cgraph_remove_node (node);
+  return found;
 }
 
 /* Notify finalize_compilation_unit that given node is reachable.  */
Index: gcc/cgraph.h
===================================================================
--- gcc/cgraph.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/cgraph.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -547,7 +547,7 @@
 void cgraph_insert_node_to_hashtable (struct cgraph_node *node);
 void cgraph_remove_edge (struct cgraph_edge *);
 void cgraph_remove_node (struct cgraph_node *);
-void cgraph_remove_node_and_inline_clones (struct cgraph_node *);
+bool cgraph_remove_node_and_inline_clones (struct cgraph_node *, struct cgraph_node *);
 void cgraph_release_function_body (struct cgraph_node *);
 void cgraph_node_remove_callees (struct cgraph_node *node);
 struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,
Index: gcc/DATESTAMP
===================================================================
--- gcc/DATESTAMP	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/DATESTAMP	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1 +1 @@
-20120301
+20120808
Index: gcc/target.h
===================================================================
--- gcc/target.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/target.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -128,7 +128,8 @@
   scalar_to_vec,
   cond_branch_not_taken,
   cond_branch_taken,
-  vec_perm
+  vec_perm,
+  vec_promote_demote
 };
 
 /* Sets of optimization levels at which an option may be enabled by
Index: gcc/configure
===================================================================
--- gcc/configure	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/configure	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -4842,7 +4842,7 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_cv_cc_gcc_supports_ada" >&5
 $as_echo "$acx_cv_cc_gcc_supports_ada" >&6; }
 
-if test x$GNATBIND != xno && test x$GNATMAKE != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
+if test "x$GNATBIND" != xno && test "x$GNATMAKE" != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
   have_gnat=yes
 else
   have_gnat=no
Index: gcc/toplev.c
===================================================================
--- gcc/toplev.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/toplev.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1326,6 +1326,13 @@
 	   "and -ftree-loop-linear)");
 #endif
 
+  if (flag_strict_volatile_bitfields > 0 && !abi_version_at_least (2))
+    {
+      warning (0, "-fstrict-volatile-bitfields disabled; "
+	       "it is incompatible with ABI versions < 2");
+      flag_strict_volatile_bitfields = 0;
+    }
+
   /* Unrolling all loops implies that standard loop unrolling must also
      be done.  */
   if (flag_unroll_all_loops)
Index: gcc/DEV-PHASE
===================================================================
--- gcc/DEV-PHASE	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/DEV-PHASE	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1 @@
+prerelease
Index: gcc/cgraphunit.c
===================================================================
--- gcc/cgraphunit.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/cgraphunit.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -2157,8 +2157,19 @@
             first_clone->ipa_transforms_to_apply);
   first_clone->ipa_transforms_to_apply = NULL;
 
+  /* When doing recursive inlining, the clone may become unnecessary.
+     This is possible i.e. in the case when the recursive function is proved to be
+     non-throwing and the recursion happens only in the EH landing pad.
+     We can not remove the clone until we are done with saving the body.
+     Remove it now.  */
+  if (!first_clone->callers)
+    {
+      cgraph_remove_node_and_inline_clones (first_clone, NULL);
+      first_clone = NULL;
+    }
 #ifdef ENABLE_CHECKING
-  verify_cgraph_node (first_clone);
+  else
+    verify_cgraph_node (first_clone);
 #endif
   return first_clone;
 }
Index: gcc/ChangeLog
===================================================================
--- gcc/ChangeLog	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/ChangeLog	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,3 +1,530 @@
+2012-07-22  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/33135
+	* config/sh/sh.opt (mieee): Use Var instead of Mask.  Correct
+	description.
+	* config/sh/sh.c (sh_option_override): Do not change 
+	flag_finite_math_only.  Set TARGET_IEEE to complement of
+	flag_finite_math_only.
+	* doc/invoke.texi (SH options): Add mno-ieee.  Correct
+	description of mieee and mno-ieee behavior.
+
+2012-07-16  Steven Bosscher  <steven@gcc.gnu.org>
+
+	Backported from trunk:
+	2012-07-13  Richard Sandiford  <rdsandiford@googlemail.com>
+		    Steven Bosscher  <steven@gcc.gnu.org>
+		    Bernd Schmidt  <bernds@codesourcery.com>
+
+	PR rtl-optimization/53908
+	* df-problems.c	(can_move_insns_across): When doing
+	memory-reference book-keeping, handle call insns.
+
+2012-07-06  Nick Clifton  <nickc@redhat.com>
+
+	* config/mn10300/mn10300.c (mn10300_encode_section_info): Call
+	default_encode_section_info.
+
+2012-07-04  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/53433
+	* tree-ssa-ccp.c (get_base_constructor): Do not return an
+	error_mark_node DECL_INITIAL.
+
+2012-07-02  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/38474
+	* ipa-prop.c (compute_known_type_jump_func): Check for a BINFO before
+	checking for a dynamic type change.
+
+2012-06-28  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/53790
+	* expr.c (expand_expr_real_1): Verify if the type is complete
+	before inspecting its size.
+
+2012-06-22  Richard Guenther  <rguenther@suse.de>
+
+	* gcov-iov.c: Include bconfig.h and system.h.
+
+2012-06-22  Richard Guenther  <rguenther@suse.de>
+
+	PR gcov-profile/53744
+	* gcov-iov.c (main): Treat "" and "prerelease" the same.
+
+2012-06-19  Joey Ye  <joey.ye@arm.com>
+
+	Backported from mainline
+	2011-10-14  David Alan Gilbert  <david.gilbert@linaro.org>
+
+	* config/arm/arm.h (TARGET_HAVE_DMB_MCR): MCR Not available in Thumb1.
+
+2012-06-18  Joey Ye  <joey.ye@arm.com>
+
+	Backported from mainline
+	2011-10-14  David Alan Gilbert  <david.gilbert@linaro.org>
+
+	PR target/48126
+	* config/arm/arm.c (arm_output_sync_loop): Move label before barrier.
+
+2012-06-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2012-06-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (vcvtph2ps): Fix vec_select selector.
+
+2012-06-16  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline:
+	2012-06-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* config/pa/pa.h (MAX_PCREL17F_OFFSET): Define.
+	* config/pa/pa.c (pa_attr_length_millicode_call): Use
+	MAX_PCREL17F_OFFSET instead of fixed offset.
+	(pa_attr_length_call): Likewise.
+	(pa_attr_length_indirect_call): Likewise.
+
+2012-06-12  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/53621
+	* config/sh/sh.c (sh_option_override): Don't force
+	 flag_omit_frame_pointer and maccumulate_outgoing_args.
+	* config/sh/sh.opt (maccumulate-outgoing-args): Init as Var.
+
+2012-06-05  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2011-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	* gthr-posix.h (__gthread_active_p): Do not use preprocessor
+	conditionals and comments inside macro arguments.
+
+2012-06-04  Edmar Wienskoski  <edmar@freescale.com>
+
+	PR target/53559
+	* config/rs6000/altivec.md (altivec_stvlx): Change machine mode of
+	operands.
+	(altivec_stvlxl): Ditto.
+	(altivec_stvrx): Ditto.
+	(altivec_stvrxl): Ditto.
+
+2012-06-04  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2012-06-04 mainline r188172
+
+	PR target/46261
+	* config/avr/avr-stdint.h: New file.
+	* config.gcc (avr-*-*,tm_file): Use avr/avr-stdint.h instead of
+	newlib-stdint.h
+
+2012-06-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/52999
+	* config/pa/pa.c (TARGET_SECTION_TYPE_FLAGS): Define.
+	(pa_section_type_flags): New.
+	* config/pa/pa.h (LEGITIMATE_CONSTANT_P): Revert previous change.
+
+2012-05-31  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/53541
+	* tree-pretty-print.c (dump_generic_node): Guard against
+	NULL_TREE TREE_TYPE when dumping MEM_REF offset type.
+
+2012-05-24  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2012-05-18  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/53385
+	* config/rs6000/rs6000.c (print_operand): Revise code that unsafely
+	relied on signed overflow behavior.
+
+2012-05-22  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-11-10  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/51071
+	* gimple.c (gimple_has_side_effects): Remove checking code
+	that doesn't belong here.
+
+2012-05-22  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2012-02-28  Richard Guenther  <rguenther@suse.de>
+
+	PR target/52407
+	* config/i386/i386.c (ix86_expand_vector_set): Fix element
+	ordering for the VEC_CONCAT for two element vectors for
+	V2SFmode, V2SImode and V2DImode.
+
+2012-05-22  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2012-04-12  Richard Guenther  <rguenther@suse.de>
+
+	PR c/52862
+	* convert.c (convert_to_pointer): Remove special-casing of zero.
+
+2012-05-21  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/53418
+	* c-typeck.c (build_conditional_expr): Remove C_MAYBE_CONST_EXPR
+	from folded operands before wrapping another around the
+	conditional expression.
+
+2012-05-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2012-05-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/53416
+	* config/i386/i386.md (UNSPEC_RDRAND): Renamed to ...
+	(UNSPECV_RDRAND): This.
+	(rdrand<mode>_1): Updated.
+
+2012-05-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2012-05-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/driver-i386.c (host_detect_local_cpu): Support
+	RDRND, F16C and FSGSBASE.
+
+2012-05-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* configure: Regenerate.
+
+2012-05-14  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/46098
+	* config/i386/i386.c (ix86_expand_special_args_builtin): Always
+	generate target register for "load" class builtins.
+
+	Revert:
+	2010-10-22  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/46098
+	* config/i386/sse.md (*avx_movu<ssemodesuffix><avxmodesuffix>):
+	Rename from avx_movu<ssemodesuffix><avxmodesuffix>.
+	(avx_movu<ssemodesuffix><avxmodesuffix>): New expander.
+	(*<sse>_movu<ssemodesuffix>): Rename from <sse>_movu<ssemodesuffix>.
+	(<sse>_movu<ssemodesuffix>): New expander.
+	(*avx_movdqu<avxmodesuffix>): Rename from avx_movdqu<avxmodesuffix>.
+	(avx_movdqu<avxmodesuffix>): New expander.
+	(*sse2_movdqu): Rename from sse2_movdqu.
+	(sse2_movdqu): New expander.
+
+2012-05-13  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2012-05-12  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.c (alpha_emit_conditional_branch): Handle
+	ORDERED and UNORDERED conditions.
+
+2012-05-06  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/52999
+	* config/pa/pa.h (LEGITIMATE_CONSTANT_P): Don't put function labels
+	in constant pool.
+
+2012-05-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2012-05-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/53228
+	* config/i386/i386.h (X86_ARCH_CMOV): Rename from X86_ARCH_CMOVE.
+	(TARGET_CMOV): Rename from TARGET_CMOVE.
+	(TARGET_CMOVE): New define.
+	* config/i386/i386.c (ix86_option_override_internal): Use TARGET_CMOV.
+	Do not set TARGET_CMOVE here.
+
+2012-05-03  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from the mainline
+	2012-05-03  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/53199
+	* config/rs6000/rs6000.md (bswapdi splitters): If
+	-mavoid-indexed-addresses (or -mcpu=power6 which sets it by
+	default) is used, generate an alternate sequence that does not
+	depend on using indexed addressing.
+
+2012-04-30  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2012-04-27  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR target/53138
+	* config/i386/i386.md (x86_mov<mode>cc_0_m1_neg): Add clobber.
+
+2012-04-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/53084
+	* varasm.c (compute_reloc_for_constant): Handle ADDR_EXPR of MEM_REF.
+	(output_addressed_constants): Likewise.
+
+2012-04-20  Thomas Schwinge  <thomas@codesourcery.com>
+
+	struct siginfo vs. siginfo_t
+
+	Backport from trunk (but apply to gcc/):
+
+	2012-04-20  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* config/alpha/linux-unwind.h (alpha_fallback_frame_state): Use
+	siginfo_t instead of struct siginfo.
+	* config/bfin/linux-unwind.h (bfin_fallback_frame_state): Likewise.
+	* config/i386/linux-unwind.h (x86_fallback_frame_state): Likewise.
+	* config/ia64/linux-unwind.h (ia64_fallback_frame_state)
+	(ia64_handle_unwabi): Likewise.
+	* config/mips/linux-unwind.h (mips_fallback_frame_state): Likewise.
+	* config/pa/linux-unwind.h (pa32_fallback_frame_state): Likewise.
+	* config/sh/linux-unwind.h (shmedia_fallback_frame_state)
+	(sh_fallback_frame_state): Likewise.
+	* config/xtensa/linux-unwind.h (xtensa_fallback_frame_state): Likewise.
+
+2012-04-13  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2012-04-12  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/52775
+	* config/rs6000/rs6000.h (TARGET_FCFID): Add TARGET_PPC_GPOPT to
+	the list of options to enable the FCFID instruction.
+
+2012-04-12  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/49448
+	* config.gcc (arm*-*-linux*): Use an unambiguous pattern for
+	detecting big-endian triplets.
+
+2012-04-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR middle-end/52894
+	* varasm.c (process_pending_assemble_externals): Set
+	pending_assemble_externals_processed true.
+	(assemble_external): Call assemble_external_real if the pending
+	assemble externals have been processed.
+
+2012-04-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/52717
+	* config/sparc/sparc.c (sparc_file_end): Set TREE_PUBLIC explicitly on
+	the DECL generated for the special GOT helper.
+
+2012-04-06  Matt Turner  <mattst88@gmail.com>
+
+	* doc/install.texi: Correct typo "-mno-lsc" -> "-mno-llsc".
+
+2012-03-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (avx_h<plusminus_insn>v4df3): Fix results
+	crossing 128bit lane boundary.
+
+2012-03-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from mainline
+	2012-03-27  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/52698
+	* config/i386/i386-protos.h (ix86_legitimize_reload_address):
+	New prototype.
+	* config/i386/i386.h (LEGITIMIZE_RELOAD_ADDRESS): New define.
+	* config/i386/i386.c: Include reload.h.
+	(ix86_legitimize_reload_address): New function.
+
+2012-03-28  Joey Ye  <joey.ye@arm.com>
+
+	Backported from mainline
+	2011-12-20  Bernd Schmidt  <bernds@codesourcery.com>
+
+	PR middle-end/51200
+	* expr.c (store_field): Avoid a direct store if the mode is larger
+	than the size of the bit field.
+	* stor-layout.c (layout_decl): If flag_strict_volatile_bitfields,
+	treat non-volatile bit fields like volatile ones.
+	* toplev.c (process_options): Disallow combination of
+	-fstrict-volatile-bitfields and ABI versions less than 2.
+	* config/arm/arm.c (arm_option_override): Don't enable
+	flag_strict_volatile_bitfields if the ABI version is less than 2.
+	* config/h8300/h8300.c (h8300_option_override): Likewise.
+	* config/rx/rx.c (rx_option_override): Likewise.
+	* config/m32c/m32c.c (m32c_option_override): Likewise.
+	* config/sh/sh.c (sh_option_override): Likewise.
+
+	2011-12-22  Joey Ye  <joey.ye@arm.com>
+
+	* toplev.c (process_options): Fix typo.
+
+2012-03-28  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from mainline
+	2012-03-27  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/52693
+	* tree-sra.c (sra_modify_assign): Do not call
+	load_assign_lhs_subreplacements when working with an unscalarizable
+	region.
+
+2012-03-28  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/52741
+
+	Revert r181936 from 2011-12-02 for:
+	* config/avr/libgcc.S (__prologue_saves__, __epilogue_restores__)
+	* config/avr/avr.md (movhi_sp_r_irq_off, movhi_sp_r_irq_on)
+	* config/avr/avr.c (output_movhi, avr_file_start)
+
+2012-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/52736
+	* config/i386/sse.md (sse2_loadlpd splitter): Use offset 0
+	instead of 8 in adjust_address.
+
+2012-03-24  Jan Hubicka  <jh@suse.cz>
+
+	Backport from mainline
+	PR regression/52696
+	* predict.c (predict_paths_for_bb): Fix typo.
+
+2012-03-24  Jan Hubicka  <jh@suse.cz>
+
+	Backport from mainline
+	PR middle-end/51737
+	* cgraph.c (cgraph_remove_node_and_inline_clones): Add FORBIDDEN_NODE
+	parameter.
+	* cgraph.h (cgraph_remove_node_and_inline_clones): Update prototype.
+	* ipa-inline-transform.c (save_inline_function_body): Remove copied
+	clone if needed.
+	* tree-inline.c (delete_unreachable_blocks_update_callgraph): Update.
+
+2012-03-24  Steven Bosscher  <steven@gcc.gnu.org>
+
+	PR middle-end/52640
+	* varasm.c: Include pointer-set.h.
+	(pending_assemble_externals_set): New pointer set.
+	(process_pending_assemble_externals): Destroy the pointer set.
+	(assemble_external): See if decl is in pending_assemble_externals_set,
+	and add it to pending_assemble_externals if necessary.
+	(init_varasm_once): Allocate pending_assemble_externals_set.
+
+2012-03-16  Jan Hubicka  <jh@suse.cz>
+
+	Backport from mainline
+	PR middle-end/48600
+	* predict.c (predict_paths_for_bb): Prevent looping.
+	(predict_paths_leading_to_edge, predict_paths_leading_to): Update.
+
+2012-03-16  Michael Hope  <michael.hope@linaro.org>
+
+	Backport from mainline
+	2011-05-05  Michael Hope  <michael.hope@linaro.org>
+
+	PR pch/45979
+	* config/host-linux.c (TRY_EMPTY_VM_SPACE): Define for
+	__ARM_EABI__ hosts.
+
+2012-03-15  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	Backport from mainline
+	2012-03-10  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	PR rtl-optimization/52528
+	* combine.c (can_combine_p): Add setting of subst_low_luid
+	before call to expand_field_assignment().
+
+2012-03-12  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline
+	2011-09-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR Bug middle-end/50232
+	* config/pa/pa.md (return): Define "return" insn pattern.
+	(epilogue): Use it when no epilogue is needed.
+	* config/pa/pa.c (pa_can_use_return_insn): New function.
+	* config/pa/pa-protos.h (pa_can_use_return_insn): Declare.
+
+	Backport for mainline
+	2012-01-28  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/51871
+	* config/pa/pa.c (pa_return_addr_rtx): Add support for PA2.0 export
+	stubs.
+
+2012-03-06  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	PR target/50310
+	* config/rs6000/vector.md (vector_uneq<mode>): Add support for
+	UNEQ, LTGT, ORDERED, and UNORDERED IEEE vector comparisons.
+	(vector_ltgt<mode>): Likewise.
+	(vector_ordered<mode>): Likewise.
+	(vector_unordered<mode>): Likewise.
+	* config/rs6000/rs6000.c (rs6000_emit_vector_compare_inner): Likewise.
+
+2012-03-04  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline
+	2012-03-01  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/52408
+	* config/pa/pa.md (zvdep_imm32): Change type of variable x from int to
+	unsigned HOST_WIDE_INT.
+	(zvdep_imm64): Likewise.
+	(vdepi_ior): Change type of variable x from int to HOST_WIDE_INT.
+	(vdepi_and): Likewise.
+	Likewise for unamed 64-bit patterns.
+	* config/pa/predicates.md (lhs_lshift_cint_operand): Update comment.
+
+2012-03-03  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/52425
+	Backport from mainline
+	2011-05-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc.c (sparc_delegitimize_address): Handle
+	UNSPEC_MOVE_PIC pattern.
+
+2012-03-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2012-03-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* config/rs6000/vsx.md (vsx_set_<mode>): Reorder operands.
+
+2012-03-02  Bill Schmidt <wschmidt@linux.vnet.ibm.com>
+	    Ira Rosen <irar@il.ibm.com>
+
+	PR tree-optimization/50031
+	PR tree-optimization/50969
+	* targhooks.c (default_builtin_vectorization_cost): Handle
+	vec_promote_demote.
+	* target.h (enum vect_cost_for_stmt): Add vec_promote_demote.
+	* tree-vect-loop.c (vect_get_single_scalar_iteraion_cost): Handle
+	all types of reduction and pattern statements.
+	(vect_estimate_min_profitable_iters): Likewise.
+	* tree-vect-stmts.c (vect_model_promotion_demotion_cost): New function.
+	(vect_model_store_cost): Use vec_perm rather than vector_stmt for
+	statement cost.
+	(vect_model_load_cost): Likewise.
+	(vect_get_load_cost): Likewise; add dump logic for explicit realigns.
+	(vectorizable_type_demotion): Call vect_model_promotion_demotion_cost.
+	(vectorizable_type_promotion): Likewise.
+	* config/spu/spu.c (spu_builtin_vectorization_cost): Handle
+	vec_promote_demote.
+	* config/i386/i386.c (ix86_builtin_vectorization_cost): Likewise.
+	* config/rs6000/rs6000.c (rs6000_builtin_vectorization_cost): Update
+	vec_perm for VSX and handle vec_promote_demote.
+
+2012-03-01  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 4.6.4.
+	* DEV-PHASE: Set to prerelease.
+
 2012-03-01  Release Manager
 
 	* GCC 4.6.3 released.
Index: gcc/testsuite/gcc.target/arm/volatile-bitfields-4.c
===================================================================
--- gcc/testsuite/gcc.target/arm/volatile-bitfields-4.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/arm/volatile-bitfields-4.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,30 @@
+/* { dg-require-effective-target arm_eabi } */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-times "ldr\[\\t \]+\[^\n\]*,\[\\t \]*\\\[\[^\n\]*\\\]" 2 } } */
+/* { dg-final { scan-assembler-times "str\[\\t \]+\[^\n\]*,\[\\t \]*\\\[\[^\n\]*\\\]" 2 } } */
+/* { dg-final { scan-assembler-not "strb" } } */
+
+struct thing {
+  unsigned a: 8;
+  unsigned b: 8;
+  unsigned c: 8;
+  unsigned d: 8;
+};
+
+struct thing2 {
+  volatile unsigned a: 8;
+  volatile unsigned b: 8;
+  volatile unsigned c: 8;
+  volatile unsigned d: 8;
+};
+
+void test1(volatile struct thing *t)
+{
+  t->a = 5;
+}
+
+void test2(struct thing2 *t)
+{
+  t->a = 5;
+}
Index: gcc/testsuite/gcc.target/powerpc/cell_builtin-7.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/cell_builtin-7.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/powerpc/cell_builtin-7.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "stvrx" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void sc3(vsc v, long a, void *p)    { __builtin_altivec_stvrx (v,a,p); }
+void srx01(vsf v, long a, vsf *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx02(vsf v, long a, sf *p)    { __builtin_vec_stvrx (v,a,p); }
+void srx03(vbi v, long a, vbi *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx04(vsi v, long a, vsi *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx05(vsi v, long a, si *p)    { __builtin_vec_stvrx (v,a,p); }
+void srx06(vui v, long a, vui *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx07(vui v, long a, ui *p)    { __builtin_vec_stvrx (v,a,p); }
+void srx08(vbs v, long a, vbs *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx09(vp v, long a, vp *p)     { __builtin_vec_stvrx (v,a,p); }
+void srx10(vss v, long a, vss *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx11(vss v, long a, ss *p)    { __builtin_vec_stvrx (v,a,p); }
+void srx12(vus v, long a, vus *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx13(vus v, long a, us *p)    { __builtin_vec_stvrx (v,a,p); }
+void srx14(vbc v, long a, vbc *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx15(vsc v, long a, vsc *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx16(vsc v, long a, sc *p)    { __builtin_vec_stvrx (v,a,p); }
+void srx17(vuc v, long a, vuc *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx18(vuc v, long a, uc *p)    { __builtin_vec_stvrx (v,a,p); }
Index: gcc/testsuite/gcc.target/powerpc/cell_builtin-8.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/cell_builtin-8.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/powerpc/cell_builtin-8.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "stvrxl" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void sc4(vsc v, long a, void *p)    { __builtin_altivec_stvrxl (v,a,p); }
+void srxl01(vsf v, long a, vsf *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl02(vsf v, long a, sf *p)   { __builtin_vec_stvrxl (v,a,p); }
+void srxl03(vbi v, long a, vbi *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl04(vsi v, long a, vsi *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl05(vsi v, long a, si *p)   { __builtin_vec_stvrxl (v,a,p); }
+void srxl06(vui v, long a, vui *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl07(vui v, long a, ui *p)   { __builtin_vec_stvrxl (v,a,p); }
+void srxl08(vbs v, long a, vbs *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl09(vp v, long a, vp *p)    { __builtin_vec_stvrxl (v,a,p); }
+void srxl10(vss v, long a, vss *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl11(vss v, long a, ss *p)   { __builtin_vec_stvrxl (v,a,p); }
+void srxl12(vus v, long a, vus *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl13(vus v, long a, us *p)   { __builtin_vec_stvrxl (v,a,p); }
+void srxl14(vbc v, long a, vbc *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl15(vsc v, long a, vsc *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl16(vsc v, long a, sc *p)   { __builtin_vec_stvrxl (v,a,p); }
+void srxl17(vuc v, long a, vuc *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl18(vuc v, long a, uc *p)   { __builtin_vec_stvrxl (v,a,p); }
Index: gcc/testsuite/gcc.target/powerpc/pr52775.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/pr52775.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/powerpc/pr52775.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-options "-O1 -mcpu=power4" } */
+/* { dg-final { scan-assembler-times "fcfid" 2 } } */
+
+double
+int_to_double (int *p)
+{
+  return (double)*p;
+}
+
+double
+long_long_to_double (long long *p)
+{
+  return (double)*p;
+}
Index: gcc/testsuite/gcc.target/powerpc/cell_builtin-1.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/cell_builtin-1.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/powerpc/cell_builtin-1.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "lvlx" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lc1(long a, void *p)           { return __builtin_altivec_lvlx (a,p); }
+vsf  llx01(long a, vsf *p)          { return __builtin_vec_lvlx (a,p); }
+vsf  llx02(long a, sf *p)           { return __builtin_vec_lvlx (a,p); }
+vbi  llx03(long a, vbi *p)          { return __builtin_vec_lvlx (a,p); }
+vsi  llx04(long a, vsi *p)          { return __builtin_vec_lvlx (a,p); }
+vsi  llx05(long a, si *p)           { return __builtin_vec_lvlx (a,p); }
+vui  llx06(long a, vui *p)          { return __builtin_vec_lvlx (a,p); }
+vui  llx07(long a, ui *p)           { return __builtin_vec_lvlx (a,p); }
+vbs  llx08(long a, vbs *p)          { return __builtin_vec_lvlx (a,p); }
+vp   llx09(long a, vp *p)           { return __builtin_vec_lvlx (a,p); }
+vss  llx10(long a, vss *p)          { return __builtin_vec_lvlx (a,p); }
+vss  llx11(long a, ss *p)           { return __builtin_vec_lvlx (a,p); }
+vus  llx12(long a, vus *p)          { return __builtin_vec_lvlx (a,p); }
+vus  llx13(long a, us *p)           { return __builtin_vec_lvlx (a,p); }
+vbc  llx14(long a, vbc *p)          { return __builtin_vec_lvlx (a,p); }
+vsc  llx15(long a, vsc *p)          { return __builtin_vec_lvlx (a,p); }
+vsc  llx16(long a, sc *p)           { return __builtin_vec_lvlx (a,p); }
+vuc  llx17(long a, vuc *p)          { return __builtin_vec_lvlx (a,p); }
+vuc  llx18(long a, uc *p)           { return __builtin_vec_lvlx (a,p); }
Index: gcc/testsuite/gcc.target/powerpc/pr52457.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/pr52457.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/powerpc/pr52457.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,34 @@
+/* { dg-do run { target { powerpc*-*-linux* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-skip-if "" { powerpc*-*-*spe* } { "*" } { "" } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O1 -mcpu=power7" } */
+
+extern void abort (void);
+
+typedef long long T;
+typedef T vl_t __attribute__((vector_size(2 * sizeof (T))));
+
+vl_t
+buggy_func (T x)
+{
+  vl_t w;
+  T *p = (T *)&w;
+  p[0] = p[1] = x;
+  return w;
+}
+
+int
+main(void)
+{
+  vl_t rval;
+  T *pl;
+
+  pl = (T *) &rval;
+  rval = buggy_func (2);
+
+  if (pl[0] != 2 || pl[1] != 2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/cell_builtin-2.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/cell_builtin-2.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/powerpc/cell_builtin-2.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "lvlxl" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lc2(long a, void *p)           { return __builtin_altivec_lvlxl (a,p); }
+vsf  llxl01(long a, vsf *p)         { return __builtin_vec_lvlxl (a,p); }
+vsf  llxl02(long a, sf *p)          { return __builtin_vec_lvlxl (a,p); }
+vbi  llxl03(long a, vbi *p)         { return __builtin_vec_lvlxl (a,p); }
+vsi  llxl04(long a, vsi *p)         { return __builtin_vec_lvlxl (a,p); }
+vsi  llxl05(long a, si *p)          { return __builtin_vec_lvlxl (a,p); }
+vui  llxl06(long a, vui *p)         { return __builtin_vec_lvlxl (a,p); }
+vui  llxl07(long a, ui *p)          { return __builtin_vec_lvlxl (a,p); }
+vbs  llxl08(long a, vbs *p)         { return __builtin_vec_lvlxl (a,p); }
+vp   llxl09(long a, vp *p)          { return __builtin_vec_lvlxl (a,p); }
+vss  llxl10(long a, vss *p)         { return __builtin_vec_lvlxl (a,p); }
+vss  llxl11(long a, ss *p)          { return __builtin_vec_lvlxl (a,p); }
+vus  llxl12(long a, vus *p)         { return __builtin_vec_lvlxl (a,p); }
+vus  llxl13(long a, us *p)          { return __builtin_vec_lvlxl (a,p); }
+vbc  llxl14(long a, vbc *p)         { return __builtin_vec_lvlxl (a,p); }
+vsc  llxl15(long a, vsc *p)         { return __builtin_vec_lvlxl (a,p); }
+vsc  llxl16(long a, sc *p)          { return __builtin_vec_lvlxl (a,p); }
+vuc  llxl17(long a, vuc *p)         { return __builtin_vec_lvlxl (a,p); }
+vuc  llxl18(long a, uc *p)          { return __builtin_vec_lvlxl (a,p); }
Index: gcc/testsuite/gcc.target/powerpc/cell_builtin-3.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/cell_builtin-3.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/powerpc/cell_builtin-3.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "lvrx" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lc3(long a, void *p)           { return __builtin_altivec_lvrx (a,p); }
+vsf  lrx01(long a, vsf *p)          { return __builtin_vec_lvrx (a,p); }
+vsf  lrx02(long a, sf *p)           { return __builtin_vec_lvrx (a,p); }
+vbi  lrx03(long a, vbi *p)          { return __builtin_vec_lvrx (a,p); }
+vsi  lrx04(long a, vsi *p)          { return __builtin_vec_lvrx (a,p); }
+vsi  lrx05(long a, si *p)           { return __builtin_vec_lvrx (a,p); }
+vui  lrx06(long a, vui *p)          { return __builtin_vec_lvrx (a,p); }
+vui  lrx07(long a, ui *p)           { return __builtin_vec_lvrx (a,p); }
+vbs  lrx08(long a, vbs *p)          { return __builtin_vec_lvrx (a,p); }
+vp   lrx09(long a, vp *p)           { return __builtin_vec_lvrx (a,p); }
+vss  lrx10(long a, vss *p)          { return __builtin_vec_lvrx (a,p); }
+vss  lrx11(long a, ss *p)           { return __builtin_vec_lvrx (a,p); }
+vus  lrx12(long a, vus *p)          { return __builtin_vec_lvrx (a,p); }
+vus  lrx13(long a, us *p)           { return __builtin_vec_lvrx (a,p); }
+vbc  lrx14(long a, vbc *p)          { return __builtin_vec_lvrx (a,p); }
+vsc  lrx15(long a, vsc *p)          { return __builtin_vec_lvrx (a,p); }
+vsc  lrx16(long a, sc *p)           { return __builtin_vec_lvrx (a,p); }
+vuc  lrx17(long a, vuc *p)          { return __builtin_vec_lvrx (a,p); }
+vuc  lrx18(long a, uc *p)           { return __builtin_vec_lvrx (a,p); }
Index: gcc/testsuite/gcc.target/powerpc/cell_builtin-4.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/cell_builtin-4.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/powerpc/cell_builtin-4.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "lvrxl" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lc4(long a, void *p)           { return __builtin_altivec_lvrxl (a,p); }
+vsf  lrxl01(long a, vsf *p)         { return __builtin_vec_lvrxl (a,p); }
+vsf  lrxl02(long a, sf *p)          { return __builtin_vec_lvrxl (a,p); }
+vbi  lrxl03(long a, vbi *p)         { return __builtin_vec_lvrxl (a,p); }
+vsi  lrxl04(long a, vsi *p)         { return __builtin_vec_lvrxl (a,p); }
+vsi  lrxl05(long a, si *p)          { return __builtin_vec_lvrxl (a,p); }
+vui  lrxl06(long a, vui *p)         { return __builtin_vec_lvrxl (a,p); }
+vui  lrxl07(long a, ui *p)          { return __builtin_vec_lvrxl (a,p); }
+vbs  lrxl08(long a, vbs *p)         { return __builtin_vec_lvrxl (a,p); }
+vp   lrxl09(long a, vp *p)          { return __builtin_vec_lvrxl (a,p); }
+vss  lrxl10(long a, vss *p)         { return __builtin_vec_lvrxl (a,p); }
+vss  lrxl11(long a, ss *p)          { return __builtin_vec_lvrxl (a,p); }
+vus  lrxl12(long a, vus *p)         { return __builtin_vec_lvrxl (a,p); }
+vus  lrxl13(long a, us *p)          { return __builtin_vec_lvrxl (a,p); }
+vbc  lrxl14(long a, vbc *p)         { return __builtin_vec_lvrxl (a,p); }
+vsc  lrxl15(long a, vsc *p)         { return __builtin_vec_lvrxl (a,p); }
+vsc  lrxl16(long a, sc *p)          { return __builtin_vec_lvrxl (a,p); }
+vuc  lrxl17(long a, vuc *p)         { return __builtin_vec_lvrxl (a,p); }
+vuc  lrxl18(long a, uc *p)          { return __builtin_vec_lvrxl (a,p); }
Index: gcc/testsuite/gcc.target/powerpc/cell_builtin-5.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/cell_builtin-5.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/powerpc/cell_builtin-5.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "stvlx" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void sc1(vsc v, long a, void *p)    { __builtin_altivec_stvlx (v,a,p); }
+void slx01(vsf v, long a, vsf *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx02(vsf v, long a, sf *p)    { __builtin_vec_stvlx (v,a,p); }
+void slx03(vbi v, long a, vbi *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx04(vsi v, long a, vsi *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx05(vsi v, long a, si *p)    { __builtin_vec_stvlx (v,a,p); }
+void slx06(vui v, long a, vui *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx07(vui v, long a, ui *p)    { __builtin_vec_stvlx (v,a,p); }
+void slx08(vbs v, long a, vbs *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx09(vp v, long a, vp *p)     { __builtin_vec_stvlx (v,a,p); }
+void slx10(vss v, long a, vss *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx11(vss v, long a, ss *p)    { __builtin_vec_stvlx (v,a,p); }
+void slx12(vus v, long a, vus *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx13(vus v, long a, us *p)    { __builtin_vec_stvlx (v,a,p); }
+void slx14(vbc v, long a, vbc *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx15(vsc v, long a, vsc *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx16(vsc v, long a, sc *p)    { __builtin_vec_stvlx (v,a,p); }
+void slx17(vuc v, long a, vuc *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx18(vuc v, long a, uc *p)    { __builtin_vec_stvlx (v,a,p); }
Index: gcc/testsuite/gcc.target/powerpc/pr53199.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/pr53199.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/powerpc/pr53199.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,50 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-options "-O2 -mcpu=power6 -mavoid-indexed-addresses" } */
+/* { dg-final { scan-assembler-times "lwbrx" 6 } } */
+/* { dg-final { scan-assembler-times "stwbrx" 6 } } */
+
+/* PR 51399: bswap gets an error if -mavoid-indexed-addresses was used in
+   creating the two lwbrx instructions.  */
+
+long long
+load64_reverse_1 (long long *p)
+{
+  return __builtin_bswap64 (*p);
+}
+
+long long
+load64_reverse_2 (long long *p)
+{
+  return __builtin_bswap64 (p[1]);
+}
+
+long long
+load64_reverse_3 (long long *p, int i)
+{
+  return __builtin_bswap64 (p[i]);
+}
+
+void
+store64_reverse_1 (long long *p, long long x)
+{
+  *p = __builtin_bswap64 (x);
+}
+
+void
+store64_reverse_2 (long long *p, long long x)
+{
+  p[1] = __builtin_bswap64 (x);
+}
+
+void
+store64_reverse_3 (long long *p, long long x, int i)
+{
+  p[i] = __builtin_bswap64 (x);
+}
+
+long long
+reg_reverse (long long x)
+{
+  return __builtin_bswap64 (x);
+}
Index: gcc/testsuite/gcc.target/powerpc/cell_builtin-6.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/cell_builtin-6.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/powerpc/cell_builtin-6.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "stvlxl" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void sc2(vsc v, long a, void *p)    { __builtin_altivec_stvlxl (v,a,p); }
+void slxl01(vsf v, long a, vsf *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl02(vsf v, long a, sf *p)   { __builtin_vec_stvlxl (v,a,p); }
+void slxl03(vbi v, long a, vbi *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl04(vsi v, long a, vsi *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl05(vsi v, long a, si *p)   { __builtin_vec_stvlxl (v,a,p); }
+void slxl06(vui v, long a, vui *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl07(vui v, long a, ui *p)   { __builtin_vec_stvlxl (v,a,p); }
+void slxl08(vbs v, long a, vbs *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl09(vp v, long a, vp *p)    { __builtin_vec_stvlxl (v,a,p); }
+void slxl10(vss v, long a, vss *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl11(vss v, long a, ss *p)   { __builtin_vec_stvlxl (v,a,p); }
+void slxl12(vus v, long a, vus *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl13(vus v, long a, us *p)   { __builtin_vec_stvlxl (v,a,p); }
+void slxl14(vbc v, long a, vbc *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl15(vsc v, long a, vsc *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl16(vsc v, long a, sc *p)   { __builtin_vec_stvlxl (v,a,p); }
+void slxl17(vuc v, long a, vuc *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl18(vuc v, long a, uc *p)   { __builtin_vec_stvlxl (v,a,p); }
Index: gcc/testsuite/gcc.target/i386/avx256-unaligned-load-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx256-unaligned-load-1.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/testsuite/gcc.target/i386/avx256-unaligned-load-1.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -14,6 +14,6 @@
     c[i] = a[i] * b[i+3];
 }
 
-/* { dg-final { scan-assembler-not "\\*avx_movups256/1" } } */
-/* { dg-final { scan-assembler "\\*avx_movups/1" } } */
+/* { dg-final { scan-assembler-not "avx_movups256/1" } } */
+/* { dg-final { scan-assembler "avx_movups/1" } } */
 /* { dg-final { scan-assembler "vinsertf128" } } */
Index: gcc/testsuite/gcc.target/i386/avx256-unaligned-load-3.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx256-unaligned-load-3.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/testsuite/gcc.target/i386/avx256-unaligned-load-3.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -14,6 +14,6 @@
     c[i] = a[i] * b[i+3];
 }
 
-/* { dg-final { scan-assembler-not "\\*avx_movupd256/1" } } */
-/* { dg-final { scan-assembler "\\*avx_movupd/1" } } */
+/* { dg-final { scan-assembler-not "avx_movupd256/1" } } */
+/* { dg-final { scan-assembler "avx_movupd/1" } } */
 /* { dg-final { scan-assembler "vinsertf128" } } */
Index: gcc/testsuite/gcc.target/i386/avx256-unaligned-store-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx256-unaligned-store-1.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/testsuite/gcc.target/i386/avx256-unaligned-store-1.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -17,6 +17,6 @@
     d[i] = c[i] * 20.0;
 }
 
-/* { dg-final { scan-assembler-not "\\*avx_movups256/2" } } */
+/* { dg-final { scan-assembler-not "avx_movups256/2" } } */
 /* { dg-final { scan-assembler "movups.*\\*avx_movv4sf_internal/3" } } */
 /* { dg-final { scan-assembler "vextractf128" } } */
Index: gcc/testsuite/gcc.target/i386/avx256-unaligned-store-3.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx256-unaligned-store-3.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/testsuite/gcc.target/i386/avx256-unaligned-store-3.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -17,6 +17,6 @@
     d[i] = c[i] * 20.0;
 }
 
-/* { dg-final { scan-assembler-not "\\*avx_movupd256/2" } } */
+/* { dg-final { scan-assembler-not "avx_movupd256/2" } } */
 /* { dg-final { scan-assembler "movupd.*\\*avx_movv2df_internal/3" } } */
 /* { dg-final { scan-assembler "vextractf128" } } */
Index: gcc/testsuite/gcc.target/i386/avx256-unaligned-load-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx256-unaligned-load-2.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/testsuite/gcc.target/i386/avx256-unaligned-load-2.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -24,6 +24,6 @@
     }
 }
 
-/* { dg-final { scan-assembler-not "\\*avx_movdqu256/1" } } */
-/* { dg-final { scan-assembler "\\*avx_movdqu/1" } } */
+/* { dg-final { scan-assembler-not "avx_movdqu256/1" } } */
+/* { dg-final { scan-assembler "avx_movdqu/1" } } */
 /* { dg-final { scan-assembler "vinsertf128" } } */
Index: gcc/testsuite/gcc.target/i386/pr53416.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr53416.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/i386/pr53416.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,17 @@
+/* PR target/53416 */
+/* { dg-options "-O2 -mrdrnd" } */
+
+int test (void)
+{
+  unsigned int number = 0;
+  int result0, result1, result2, result3;
+
+  result0 = __builtin_ia32_rdrand32_step (&number);
+  result1 = __builtin_ia32_rdrand32_step (&number);
+  result2 = __builtin_ia32_rdrand32_step (&number);
+  result3 = __builtin_ia32_rdrand32_step (&number);
+
+  return result0 + result1 +result2 + result3;
+}
+
+/* { dg-final { scan-assembler-times "rdrand" 4 } } */
Index: gcc/testsuite/gcc.target/i386/avx256-unaligned-load-4.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx256-unaligned-load-4.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/testsuite/gcc.target/i386/avx256-unaligned-load-4.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -14,6 +14,6 @@
     b[i] = a[i+3] * 2;
 }
 
-/* { dg-final { scan-assembler "\\*avx_movups256/1" } } */
-/* { dg-final { scan-assembler-not "\\*avx_movups/1" } } */
+/* { dg-final { scan-assembler "avx_movups256/1" } } */
+/* { dg-final { scan-assembler-not "avx_movups/1" } } */
 /* { dg-final { scan-assembler-not "vinsertf128" } } */
Index: gcc/testsuite/gcc.target/i386/avx256-unaligned-store-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx256-unaligned-store-2.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/testsuite/gcc.target/i386/avx256-unaligned-store-2.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -24,6 +24,6 @@
     }
 }
 
-/* { dg-final { scan-assembler-not "\\*avx_movdqu256/2" } } */
+/* { dg-final { scan-assembler-not "avx_movdqu256/2" } } */
 /* { dg-final { scan-assembler "movdqu.*\\*avx_movv16qi_internal/3" } } */
 /* { dg-final { scan-assembler "vextractf128" } } */
Index: gcc/testsuite/gcc.target/i386/avx256-unaligned-store-4.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx256-unaligned-store-4.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/testsuite/gcc.target/i386/avx256-unaligned-store-4.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -14,7 +14,7 @@
     b[i+3] = a[i] * c[i];
 }
 
-/* { dg-final { scan-assembler "\\*avx_movups256/2" } } */
-/* { dg-final { scan-assembler-not "\\*avx_movups/2" } } */
+/* { dg-final { scan-assembler "avx_movups256/2" } } */
+/* { dg-final { scan-assembler-not "avx_movups/2" } } */
 /* { dg-final { scan-assembler-not "\\*avx_movv4sf_internal/3" } } */
 /* { dg-final { scan-assembler-not "vextractf128" } } */
Index: gcc/testsuite/gcc.target/i386/pr52736.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr52736.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.target/i386/pr52736.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,29 @@
+/* PR target/52736 */
+/* { dg-do run } */
+/* { dg-options "-O1 -msse2" } */
+/* { dg-require-effective-target sse2_runtime } */
+
+#include <x86intrin.h>
+
+typedef double D __attribute__((may_alias));
+__attribute__((aligned(16))) static const double r[4] = { 1., 5., 1., 3. };
+
+__attribute__((noinline, noclone))
+void
+foo (int x)
+{
+  asm volatile ("" : "+g" (x) : : "memory");
+  if (x != 3)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  __m128d t = _mm_set1_pd (5.);
+  ((D *)(&t))[0] = 1.;
+  foo (_mm_movemask_pd (_mm_cmpeq_pd (t, _mm_load_pd (&r[0]))));
+  ((D *)(&t))[1] = 3.;
+  foo (_mm_movemask_pd (_mm_cmpeq_pd (t, _mm_load_pd (&r[2]))));
+  return 0;
+}
Index: gcc/testsuite/gfortran.dg/init_flag_10.f90
===================================================================
--- gcc/testsuite/gfortran.dg/init_flag_10.f90	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gfortran.dg/init_flag_10.f90	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,43 @@
+! { dg-do run }
+! { dg-options "-finit-real=NAN" }
+! { dg-add-options ieee }
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
+!
+! PR fortran/50619
+!
+! Contributed by Fred Krogh
+!
+! The NaN initialization used to set the associate name to NaN!
+!
+
+module testa2
+type, public ::  test_ty
+  real :: rmult = 1.0e0
+end type test_ty
+
+contains
+  subroutine test(e, var1)
+    type(test_ty) :: e
+    real :: var1, var2 ! Should get NaN initialized
+
+    ! Should be the default value
+    if (e%rmult /= 1.0) call abort ()
+
+    ! Check that NaN initialization is really turned on
+    if (var1 == var1) call abort () 
+    if (var2 == var2) call abort () 
+
+    ! The following was failing:
+    associate (rmult=>e%rmult)
+      if (e%rmult /= 1.0) call abort ()
+    end associate
+  end subroutine test
+end module testa2
+
+program testa1
+  use testa2
+  type(test_ty) :: e
+  real :: var1 ! Should get NaN initialized
+  call test(e, var1)
+  stop
+end program testa1
Index: gcc/testsuite/gfortran.dg/intrinsic_8.f90
===================================================================
--- gcc/testsuite/gfortran.dg/intrinsic_8.f90	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gfortran.dg/intrinsic_8.f90	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,23 @@
+! { dg-do compile }
+!
+! PR fortran/52452
+!
+! Contributed by Roger Ferrer Ibanez
+!
+PROGRAM test_etime
+    IMPLICIT NONE
+    INTRINSIC :: etime
+    REAL(4) :: tarray(1:2)
+    REAL(4) :: result
+
+    CALL etime(tarray, result)
+END PROGRAM test_etime
+
+subroutine test_etime2
+    IMPLICIT NONE
+    INTRINSIC :: etime
+    REAL(4) :: tarray(1:2)
+    REAL(4) :: result
+
+    result = etime(tarray)
+END subroutine test_etime2
Index: gcc/testsuite/gfortran.dg/optional_absent_2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/optional_absent_2.f90	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gfortran.dg/optional_absent_2.f90	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,53 @@
+! { dg-do run }
+!
+! PR fortran/51758
+!
+! Contributed by Mikael Morin
+!
+! Check whether passing NULL() to an elemental procedure works,
+! where NULL() denotes an absent optional argument.
+!
+program p
+
+  integer :: a(2)
+  integer :: b
+
+  a = 0
+  a = foo((/ 1, 1 /), null())
+!  print *, a
+  if (any(a /= 2)) call abort
+
+  a = 0
+  a = bar((/ 1, 1 /), null())
+!  print *, a
+  if (any(a /= 2)) call abort
+
+  b = 0
+  b = bar(1, null())
+!  print *, b
+  if (b /= 2) call abort
+
+contains
+
+  function foo(a, b)
+    integer           :: a(:)
+    integer, optional :: b(:)
+    integer           :: foo(size(a))
+
+    if (present(b)) call abort
+
+    foo = 2
+  end function foo
+
+  elemental function bar(a, b)
+    integer, intent(in)           :: a
+    integer, intent(in), optional :: b
+    integer                       :: bar
+
+    bar = 2
+
+    if (present(b)) bar = 1
+
+  end function bar
+
+end program p
Index: gcc/testsuite/gfortran.dg/save_4.f90
===================================================================
--- gcc/testsuite/gfortran.dg/save_4.f90	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gfortran.dg/save_4.f90	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! { dg-options "-std=f2003" }
+!
+! PR fortran/53597
+!
+MODULE somemodule
+  IMPLICIT NONE
+  TYPE sometype
+    INTEGER :: i
+    DOUBLE PRECISION, POINTER, DIMENSION(:,:) :: coef => NULL()
+  END TYPE sometype
+  TYPE(sometype) :: somevariable ! { dg-error "Fortran 2008: Implied SAVE for module variable 'somevariable' at .1., needed due to the default initialization" }
+END MODULE somemodule
Index: gcc/testsuite/gfortran.dg/proc_ptr_34.f90
===================================================================
--- gcc/testsuite/gfortran.dg/proc_ptr_34.f90	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gfortran.dg/proc_ptr_34.f90	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,79 @@
+! { dg-do compile }
+!
+! PR fortran/52469
+!
+! This was failing as the DECL of the proc pointer "func"
+! was used for the interface of the proc-pointer component "my_f_ptr"
+! rather than the decl of the proc-pointer target
+!
+! Contributed by palott@gmail.com
+!
+
+module ExampleFuncs
+  implicit none
+
+  ! NOTE: "func" is a procedure pointer!
+  pointer :: func
+  interface
+     function func (z)
+        real :: func
+        real, intent (in) :: z
+     end function func
+  end interface
+
+  type Contains_f_ptr
+     procedure (func), pointer, nopass :: my_f_ptr
+  end type Contains_f_ptr
+contains
+
+function f1 (x)
+  real :: f1
+  real, intent (in) :: x
+
+  f1 = 2.0 * x
+
+  return
+end function f1
+
+function f2 (x)
+   real :: f2
+   real, intent (in) :: x
+
+   f2 = 3.0 * x**2
+
+   return
+end function f2
+
+function fancy (func, x)
+   real :: fancy
+   real, intent (in) :: x
+
+   interface AFunc
+      function func (y)
+         real :: func
+         real, intent (in) ::y
+      end function func
+   end interface AFunc
+
+   fancy = func (x) + 3.3 * x
+end function fancy
+
+end module  ExampleFuncs
+
+
+program test_proc_ptr
+  use ExampleFuncs
+  implicit none
+
+  type (Contains_f_ptr), dimension (2) :: NewType
+ 
+  !NewType(1) % my_f_ptr => f1
+  NewType(2) % my_f_ptr => f2
+
+  !write (*, *) NewType(1) % my_f_ptr (3.0), NewType(2) % my_f_ptr (3.0)
+  write (6, *)  NewType(2) % my_f_ptr (3.0) ! < Shall print '27.0'
+
+  stop
+end program test_proc_ptr
+
+! { dg-final { cleanup-modules "examplefuncs" } }
Index: gcc/testsuite/gfortran.dg/pointer_intent_6.f90
===================================================================
--- gcc/testsuite/gfortran.dg/pointer_intent_6.f90	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gfortran.dg/pointer_intent_6.f90	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+!
+! PR fortran/52864
+!
+! Assigning to an intent(in) pointer (which is valid).
+!
+      program test
+         type PoisFFT_Solver3D
+           complex, dimension(:,:,:), &
+                           pointer :: work => null()
+         end type PoisFFT_Solver3D
+      contains
+        subroutine PoisFFT_Solver3D_FullPeriodic(D, p)
+          type(PoisFFT_Solver3D), intent(in) :: D
+          real, intent(in), pointer :: p(:)
+          D%work(i,j,k) = 0.0
+          p = 0.0
+        end subroutine
+      end
Index: gcc/testsuite/gfortran.dg/realloc_on_assign_15.f90
===================================================================
--- gcc/testsuite/gfortran.dg/realloc_on_assign_15.f90	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gfortran.dg/realloc_on_assign_15.f90	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,40 @@
+! { dg-do run }
+!
+! PR fortran/53389
+!
+! The program was leaking memory before due to
+! realloc on assignment and nested functions.
+!
+module foo
+  implicit none
+  contains
+
+  function filler(array, val)
+    real, dimension(:), intent(in):: array
+    real, dimension(size(array)):: filler
+    real, intent(in):: val
+
+    filler=val
+
+  end function filler
+end module
+
+program test
+  use foo
+  implicit none
+
+  real, dimension(:), allocatable:: x, y
+  integer, parameter:: N=1000 !*1000
+  integer:: i
+
+!  allocate( x(N) )
+  allocate( y(N) )
+  y=0.0
+
+  do i=1, N
+!    print *,i
+    x=filler(filler(y, real(2*i)), real(i))
+    y=y+x
+  end do
+
+end program test
Index: gcc/testsuite/gcc.c-torture/execute/pr53084.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr53084.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr53084.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,18 @@
+/* PR middle-end/53084 */
+
+extern void abort (void);
+
+__attribute__((noinline, noclone)) void
+bar (const char *p)
+{
+  if (p[0] != 'o' || p[1] != 'o' || p[2])
+    abort ();
+}
+
+int
+main ()
+{
+  static const char *const foo[] = {"foo" + 1};
+  bar (foo[0]);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20120427-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/20120427-1.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.c-torture/execute/20120427-1.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,36 @@
+typedef struct sreal
+{
+  unsigned sig;		/* Significant.  */
+  int exp;		/* Exponent.  */
+} sreal;
+
+sreal_compare (sreal *a, sreal *b)
+{
+  if (a->exp > b->exp)
+    return 1;
+  if (a->exp < b->exp)
+    return -1;
+  if (a->sig > b->sig)
+    return 1;
+  return -(a->sig < b->sig);
+}
+
+sreal a[] = {
+   { 0, 0 },
+   { 1, 0 },
+   { 0, 1 },
+   { 1, 1 }
+};
+
+int main()
+{
+  int i, j;
+  for (i = 0; i <= 3; i++) {
+    for (j = 0; j < 3; j++) {
+      if (i < j && sreal_compare(&a[i], &a[j]) != -1) abort();
+      if (i == j && sreal_compare(&a[i], &a[j]) != 0) abort();
+      if (i > j && sreal_compare(&a[i], &a[j]) != 1) abort();
+    }
+  }
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr53418-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr53418-1.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr53418-1.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,5 @@
+void
+f (void)
+{
+  int i = (0 ? 1 : 0U / 0);
+}
Index: gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,56 @@
+/* Inspired by the test case for PR middle-end/52640.  */
+
+typedef struct
+{
+    char *value;
+} REFERENCE;
+
+/* Add a few "extern int Xxxxxx ();" declarations.  */
+#undef DEF
+#undef LIM1
+#undef LIM2
+#undef LIM3
+#undef LIM4
+#undef LIM5
+#undef LIM6
+#define DEF(x) 	extern int x ()
+#define LIM1(x) DEF(x##0); DEF(x##1); DEF(x##2); DEF(x##3); DEF(x##4); \
+		DEF(x##5); DEF(x##6); DEF(x##7); DEF(x##8); DEF(x##9);
+#define LIM2(x) LIM1(x##0) LIM1(x##1) LIM1(x##2) LIM1(x##3) LIM1(x##4) \
+		LIM1(x##5) LIM1(x##6) LIM1(x##7) LIM1(x##8) LIM1(x##9)
+#define LIM3(x) LIM2(x##0) LIM2(x##1) LIM2(x##2) LIM2(x##3) LIM2(x##4) \
+		LIM2(x##5) LIM2(x##6) LIM2(x##7) LIM2(x##8) LIM2(x##9)
+#define LIM4(x) LIM3(x##0) LIM3(x##1) LIM3(x##2) LIM3(x##3) LIM3(x##4) \
+		LIM3(x##5) LIM3(x##6) LIM3(x##7) LIM3(x##8) LIM3(x##9)
+#define LIM5(x) LIM4(x##0) LIM4(x##1) LIM4(x##2) LIM4(x##3) LIM4(x##4) \
+		LIM4(x##5) LIM4(x##6) LIM4(x##7) LIM4(x##8) LIM4(x##9)
+#define LIM6(x) LIM5(x##0) LIM5(x##1) LIM5(x##2) LIM5(x##3) LIM5(x##4) \
+		LIM5(x##5) LIM5(x##6) LIM5(x##7) LIM5(x##8) LIM5(x##9)
+LIM5 (X);
+
+/* Add references to them, or GCC will simply ignore the extern decls.  */
+#undef DEF
+#undef LIM1
+#undef LIM2
+#undef LIM3
+#undef LIM4
+#undef LIM5
+#undef LIM6
+#define DEF(x)	(char *) x
+#define LIM1(x) DEF(x##0), DEF(x##1), DEF(x##2), DEF(x##3), DEF(x##4), \
+		DEF(x##5), DEF(x##6), DEF(x##7), DEF(x##8), DEF(x##9),
+#define LIM2(x) LIM1(x##0) LIM1(x##1) LIM1(x##2) LIM1(x##3) LIM1(x##4) \
+		LIM1(x##5) LIM1(x##6) LIM1(x##7) LIM1(x##8) LIM1(x##9)
+#define LIM3(x) LIM2(x##0) LIM2(x##1) LIM2(x##2) LIM2(x##3) LIM2(x##4) \
+		LIM2(x##5) LIM2(x##6) LIM2(x##7) LIM2(x##8) LIM2(x##9)
+#define LIM4(x) LIM3(x##0) LIM3(x##1) LIM3(x##2) LIM3(x##3) LIM3(x##4) \
+		LIM3(x##5) LIM3(x##6) LIM3(x##7) LIM3(x##8) LIM3(x##9)
+#define LIM5(x) LIM4(x##0) LIM4(x##1) LIM4(x##2) LIM4(x##3) LIM4(x##4) \
+		LIM4(x##5) LIM4(x##6) LIM4(x##7) LIM4(x##8) LIM4(x##9)
+#define LIM6(x) LIM5(x##0) LIM5(x##1) LIM5(x##2) LIM5(x##3) LIM5(x##4) \
+		LIM5(x##5) LIM5(x##6) LIM5(x##7) LIM5(x##8) LIM5(x##9)
+REFERENCE references[] = {
+  LIM5 (X)
+  0
+};
+
Index: gcc/testsuite/gcc.c-torture/compile/pr53418-2.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr53418-2.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr53418-2.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,5 @@
+void
+f (void)
+{
+  int i = (1 ? 0U / 0 : 1);
+}
Index: gcc/testsuite/gcc.dg/pr52862.c
===================================================================
--- gcc/testsuite/gcc.dg/pr52862.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.dg/pr52862.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+void ASMAtomicWritePtrVoid(const void *pv);
+void rtThreadDestroy(void)
+{
+  void * const pvTypeChecked = ((void *)0);
+  ASMAtomicWritePtrVoid((void *)(pvTypeChecked));
+}
Index: gcc/testsuite/gcc.dg/stack-usage-1.c
===================================================================
--- gcc/testsuite/gcc.dg/stack-usage-1.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/testsuite/gcc.dg/stack-usage-1.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -41,6 +41,8 @@
 #  define SIZE 160 /* 256 -  96 bytes for register save area */
 #elif defined (__SPU__)
 #  define SIZE 224
+#elif defined (__sh__)
+#  define SIZE 252
 #else
 #  define SIZE 256
 #endif
Index: gcc/testsuite/gcc.dg/torture/pr53908.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr53908.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.dg/torture/pr53908.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,288 @@
+/* { dg-do run } */
+/* SEGV at comment below.  */
+typedef unsigned int size_t;
+typedef enum har {
+  he_fatal = (-199),
+  he_not_initialized,
+  he_bad_input,
+  he_memory_too_small,
+  he_bad_action,
+  he_duplicate,
+  he_bad_nonce,
+  he_stale_nonce,
+  he_bad_credentials,
+  he_bad_user,
+  he_no_such_user,
+  he_bad_passwd,
+  he_unknown_auth_scheme,
+  he_not_found,
+  he_failed_digest_file_check,
+  he_failed_digest_file_save,
+  he_process_not_privileged,
+  he_other,
+  he_end_of_range,
+  ha_no_error = 0,
+  ha_no_value = 1
+} har;
+typedef enum realm_type
+{
+  axis_realm = 0,
+  ws_realm
+} realm_type;
+
+__attribute__((__noclone__, __noinline__))
+har has_www_auth(char *, size_t, realm_type, har);
+
+__attribute__((__noclone__, __noinline__))
+har has_auth_user(const char *, const char *, realm_type, char *, size_t);
+
+__attribute__((__noclone__, __noinline__))
+char *ha_get_string_value(void);
+
+typedef struct
+{
+  unsigned int track_id;
+  char* user;
+  char* realm;
+  char* authent;
+  int internal_realm;
+} request;
+enum user_response {
+  file_not_found_user_response = -3,
+  access_denied_user_response = -2,
+  no_user_response = -1,
+  ok_user_response = 0
+};
+struct realm_group {
+  char *name;
+  int id;
+  struct realm_group *next;
+};
+struct realm {
+  char *name;
+  char *space;
+  struct realm_group *groups;
+  struct realm *next;
+};
+struct user_info {
+  char *name;
+  int no_groups;
+  int groups[128];
+  struct user_info *next;
+};
+static struct user_info *find_user(const char *user_name);
+static int is_member_of_groups(const struct user_info *user_item,
+                                const struct realm_group *groups);
+int authent_author(request *req);
+struct realm *realms = ((void *)0);
+struct user_info *users = ((void *)0);
+static struct user_info*
+find_user(const char *user_name)
+{
+  struct user_info *user_item;
+  user_item = users;
+  while (user_item != ((void *)0)) {
+    /* SEGV due to NULL access here on user_name.  See also comment below.  */
+    if ((__builtin_strcmp(user_item->name, user_name) == 0))
+      break;
+    user_item = user_item->next;
+  }
+  return user_item;
+}
+static int
+is_member_of_groups(const struct user_info *user_item,
+                    const struct realm_group *groups)
+{
+  const struct realm_group *group_item;
+  int i;
+  group_item = groups;
+  while (group_item != ((void *)0)) {
+    for (i = 0; i < user_item->no_groups; i++)
+      if (user_item->groups[i] == group_item->id)
+	return 0;
+    group_item = group_item->next;
+  }
+  return -1;
+}
+char *foo (void) __attribute__((__noclone__, __noinline__));
+char* g_strdup (const char *str) __attribute__((__malloc__, __noclone__, __noinline__));
+int g_strcmp0 (const char *str1, const char *str2);
+static int
+is_basic(char **user)
+{
+  char *passwd_ptr;
+  char *authent = foo();
+  passwd_ptr = __builtin_strchr(authent, ':');
+  if (passwd_ptr != ((void *)0)) {
+    *user = g_strdup(authent);
+    return 0;
+  }
+  return -1;
+}
+static int
+is_digest(char **user)
+{
+  int ret_val = -1;
+  char *authent;
+  authent = ha_get_string_value();
+  if (authent) {
+    *user = g_strdup(authent);
+    ret_val = 0;
+  }
+  return ret_val;
+}
+__attribute__((__noclone__, __noinline__))
+void g_free (void * mem);
+static enum user_response
+get_user_info_from_header(const realm_type type,
+                          char **user_name,
+                          struct user_info **user_item)
+{
+  int ret_val = no_user_response;
+  if ((type == ws_realm)) {
+    if (is_basic(user_name) == 0)
+      ret_val = access_denied_user_response;
+    if (is_digest(user_name) == 0)
+      ret_val = ok_user_response;
+  } else {
+    if (is_basic(user_name) < 0 &&
+	/* Load of *user_name here, but not after the is_digest call.  */
+	is_digest(user_name) < 0)
+      ;
+    else if ((*user_item = find_user(*user_name)) != ((void *)0))
+      ret_val = ok_user_response;
+    else
+      ret_val = access_denied_user_response;
+    if (ret_val != ok_user_response)
+      g_free(*user_name);
+  }
+  return ret_val;
+}
+static enum user_response
+authenticate_user(request *req,
+                  char **user_name,
+                  struct user_info **user_item)
+{
+  char *authent = ((void *)0);
+  har resp = ha_no_value;
+  enum user_response user_resp;
+  int ret_val = no_user_response;
+  if (req->authent && __builtin_strlen(req->authent)) {
+    authent = req->authent;
+    user_resp = get_user_info_from_header(req->internal_realm,
+                                          user_name,
+                                          user_item);
+    if (user_resp == ok_user_response) {
+      resp = has_auth_user(authent, 0, req->internal_realm, "", 1);
+      if (resp == ha_no_error)
+	ret_val = ok_user_response;
+      else if (resp != he_stale_nonce)
+	ret_val = access_denied_user_response;
+    } else if (user_resp == access_denied_user_response)
+      ret_val = access_denied_user_response;
+  }
+  if (resp != he_memory_too_small && resp != ha_no_error)
+    resp = has_www_auth("", 1, req->internal_realm, resp);
+  return ret_val;
+}
+
+int __attribute__ ((__noinline__, __noclone__))
+authent_author(request *req)
+{
+  struct realm *realm;
+  char *user_name = ((void *)0);
+  struct user_info *user_item = ((void *)0);
+  int res = 0;
+  asm ("");
+  realm = realms;
+  if (__builtin_strcmp("Wsd", realm->name) == 0) {
+    req->internal_realm = ws_realm;
+    is_digest(&user_name);
+  }
+  if (authenticate_user(req, &user_name, &user_item) < 0) {
+    if (user_name != ((void *)0))
+      req->user = user_name;
+    res = -2;
+    goto authent_author_return;
+  }
+  if (is_member_of_groups(user_item, realm->groups) < 0)
+    res = -1;
+authent_author_return:
+  return res;
+}
+
+int good0, good1, good2;
+
+__attribute__ ((__noinline__, __noclone__))
+char *foo(void)
+{
+  asm ("");
+  good0++;
+  return "";
+}
+
+__attribute__ ((__noinline__, __noclone__))
+char *ha_get_string_value(void)
+{
+  asm ("");
+  good1++;
+  return "f";
+}
+
+__attribute__ ((__noinline__, __noclone__))
+har has_auth_user(const char *a, const char *b, realm_type c, char *d, size_t e)
+{
+  asm ("");
+  if (*a != 'z' || a[1] != 0 || b != 0 || c != axis_realm || *d != 0
+      || e != 1)
+    __builtin_abort ();
+  return ha_no_error;
+}
+
+__attribute__ ((__noinline__, __noclone__))
+har has_www_auth(char *a, size_t b, realm_type c, har d)
+{
+  (void)(*a+b+c+d);
+  asm ("");
+  __builtin_abort ();
+}
+
+
+char *strdupped_user = "me";
+__attribute__((__malloc__, __noclone__, __noinline__))
+char* g_strdup (const char *str)
+{
+  asm ("");
+  if (*str != 'f')
+    __builtin_abort ();
+  good2++;
+  return strdupped_user;
+}
+
+__attribute__((__noclone__, __noinline__))
+void g_free (void * mem)
+{
+  (void)mem;
+  asm ("");
+  __builtin_abort ();
+}
+
+struct user_info me = { .name = "me", .no_groups = 1, .groups = {42}, .next = 0};
+struct user_info you = { .name = "you", .next = &me};
+struct realm_group xgroups = { .name = "*", .id = 42, .next = 0};
+
+int main(void)
+{
+  char *orig_user = "?";
+  struct realm r = { .name = "x", .space = "space?", .groups = &xgroups, .next = 0};
+  request req = { .user = orig_user, .realm = "!", .authent = "z",
+		  .internal_realm = axis_realm};
+  realms = &r;
+  users = &you;
+  if (authent_author (&req) != 0 || good0 != 1 || good1 != 1 || good2 != 1
+      || req.user != orig_user
+      || req.internal_realm != axis_realm)
+    __builtin_abort ();
+  __builtin_exit (0);
+}
+
Index: gcc/testsuite/gcc.dg/torture/pr52693.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr52693.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.dg/torture/pr52693.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+struct pair
+{
+  int x;
+  int y;
+};
+
+struct array
+{
+  struct pair elems[ 2 ];
+  unsigned index;
+};
+
+extern void abort ();
+
+void __attribute__ ((noinline,noclone))
+test_results (int x1, int y1, int x2, int y2)
+{
+  if (x1 != x2 || y1 != y2)
+    abort ();
+}
+
+int
+main (void)
+{
+  struct array arr = {{{1,2}, {3,4}}, 1};
+  struct pair last = arr.elems[arr.index];
+
+  test_results ( last.x, last.y, arr.elems[1].x, arr.elems[1].y);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr53790.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr53790.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.dg/torture/pr53790.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+
+typedef struct s {
+    int value;
+} s_t;
+
+static inline int 
+read(s_t const *var)
+{
+  return var->value;
+}
+
+int main()
+{
+  extern union u extern_var;
+  return read((s_t *)&extern_var);
+}
Index: gcc/testsuite/gcc.dg/torture/pr52407.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr52407.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.dg/torture/pr52407.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+extern void abort (void);
+
+typedef long long T;
+typedef T vl_t __attribute__((vector_size(2 * sizeof (T))));
+
+vl_t	ul[4], vl[4] = { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };
+
+static void
+mul_vl_l(vl_t *u, vl_t *v, T x, int m)
+{
+  vl_t	 w;
+  T *p = (T *)&w;
+  p[0] = p[1] = x;
+  while (m--)
+    *u++ = *v++ * w;
+}
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+  T *pl;
+
+  pl = (T *) &ul;
+  mul_vl_l(ul, vl, 2, 4);
+  for (i = 0; i < 8; i++)
+    if (pl[i] != 2 * (i + 1))
+      abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr51071-2.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr51071-2.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.dg/torture/pr51071-2.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,38 @@
+/* { dg-do compile } */
+/* { dg-options "-fno-delete-null-pointer-checks" } */
+
+extern struct module __this_module;
+static inline void
+trace_module_get  (struct module *mod, unsigned long ip) { }
+struct module;
+static inline __attribute__((no_instrument_function))
+int try_module_get(struct module *module)
+{
+  int ret = 1;
+  if (module)
+    {
+      if (module_is_live(module))
+	{
+	  __label__ __here;
+	  asm("");
+	  __here:
+	  trace_module_get(module, (unsigned long)&&__here);
+	}
+      else
+	ret = 0;
+    }
+  return ret;
+}
+struct net_device;
+struct net_device_ops {
+    int (*ndo_open)(struct net_device *dev);
+};
+int t3e3_open(struct net_device *dev)
+{
+  int ret = hdlc_open(dev);
+  if (ret)
+    return ret;
+  try_module_get((&__this_module));
+  return 0;
+}
+const struct net_device_ops t3e3_ops = { .ndo_open = t3e3_open };
Index: gcc/testsuite/gcc.dg/torture/pr51071.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr51071.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.dg/torture/pr51071.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+
+void foo (void);
+void bar (void *);
+extern int t;
+
+static void kmalloc_large (int size, int flags)
+{
+  (void) size;
+  (void) flags;
+  foo ();
+  bar (({__here:&&__here;}));
+}
+
+static void kmalloc (int size, int flags)
+{
+  if (size)
+    {
+      if ((unsigned long) size > 0x1000)
+	kmalloc_large (size, flags);
+
+      if (flags)
+	bar (({__here:&&__here;}));
+    }
+}
+
+void compress_file_range (int i, int j, int k)
+{
+  int nr_pages = ({j < k;});
+
+  if (i || t)
+    kmalloc (0x1000UL * nr_pages, 0x40UL);
+}
Index: gcc/testsuite/gcc.dg/volatile-bitfields-2.c
===================================================================
--- gcc/testsuite/gcc.dg/volatile-bitfields-2.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/gcc.dg/volatile-bitfields-2.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,15 @@
+/* { dg-do run } */
+/* { dg-options "-fstrict-volatile-bitfields" } */
+
+extern void abort(void);
+struct thing {
+  volatile unsigned short a: 8;
+  volatile unsigned short b: 8;
+} t = {1,2};
+
+int main()
+{
+  t.a = 3;
+  if (t.a !=3 || t.b !=2) abort();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/20020201-1.c
===================================================================
--- gcc/testsuite/gcc.dg/20020201-1.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/testsuite/gcc.dg/20020201-1.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -7,12 +7,8 @@
 /* { dg-options "-fprofile-arcs" } */
 /* { dg-do run { target native } } */
 
-extern void abort (void);
-extern void exit (int);
+#include <stdlib.h>
 
-int rand (void);
-void srand (unsigned int seed);
-
 int globvar;
 
 void
Index: gcc/testsuite/ChangeLog
===================================================================
--- gcc/testsuite/ChangeLog	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/testsuite/ChangeLog	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,3 +1,232 @@
+2012-08-06  Anna Tikhonova  <anna.m.tikhonova@gmail.com>
+
+	* gcc.dg/20020201-1.c: Remove declarations for exit, abort,
+	rand, srand. Include <stdlib.h>.
+
+2012-07-16  Steven Bosscher  <steven@gcc.gnu.org>
+
+	Backport from trunk:
+	2012-07-13  Hans-Peter Nilsson  <hp@axis.com>
+
+	PR rtl-optimization/53908
+	* gcc.dg/torture/pr53908.c: New test.
+
+2012-07-14  Mikael Morin  <mikael.morin@gcc.gnu.org>
+
+	Backport from trunk:
+	2012-01-09  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51758
+	* gfortran.dg/optional_absent_2.f90: New.
+
+2012-07-03  Michael Hope  <michael.hope@linaro.org>
+
+	PR c++/53814
+	* g++.dg/cpp0x/nullptr28.C: Change selector for explicit
+	options.
+
+2012-06-28  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/53790
+	* gcc.dg/torture/pr53790.c: New testcase.
+
+2012-06-25  Jason Merrill  <jason@redhat.com>
+
+	PR c++/52988
+	* g++.dg/cpp0x/nullptr28.C: New.
+
+2012-06-19  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* gcc.dg/stack-usage-1.c: Remove dg-options line for sh targets
+	and add __sh__ case.
+
+2012-06-14  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/53597
+	* gfortran.dg/save_4.f90: New.
+
+2012-06-13  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/53621
+	* gcc.dg/stack-usage-1.c: Force -fomit-frame-pointer on SH.
+
+2012-06-05  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50619
+	* gfortran.dg/init_flag_10.f90: New.
+
+2012-06-04  Edmar Wienskoski  <edmar@freescale.com>
+
+	PR target/53559
+	* gcc.target/powerpc/cell_builtin_1.c: New test case.
+	* gcc.target/powerpc/cell_builtin_2.c: Ditto.
+	* gcc.target/powerpc/cell_builtin_3.c: Ditto.
+	* gcc.target/powerpc/cell_builtin_4.c: Ditto.
+	* gcc.target/powerpc/cell_builtin_5.c: Ditto.
+	* gcc.target/powerpc/cell_builtin_6.c: Ditto.
+	* gcc.target/powerpc/cell_builtin_7.c: Ditto.
+	* gcc.target/powerpc/cell_builtin_8.c: Ditto.
+
+2012-05-23  Michael Hope  <michael.hope@linaro.org>
+
+	PR c++/52796
+	* g++.dg/cpp0x/variadic-value1.C: Change selector for explicit
+	options.
+
+2012-05-23  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/53389
+	* gfortran.dg/realloc_on_assign_15.f90: New.
+
+2012-05-22  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-11-10  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/51071
+	* gcc.dg/torture/pr51071.c: New testcase.
+	* gcc.dg/torture/pr51071-2.c: Likewise.
+
+2012-05-22  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2012-02-28  Richard Guenther  <rguenther@suse.de>
+
+	PR target/52407
+	* gcc.dg/torture/pr52407.c: New testcase.
+
+2012-05-22  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2012-04-12  Richard Guenther  <rguenther@suse.de>
+
+	PR c/52862
+	* gcc.dg/pr52862.c: New testcase.
+
+2012-05-21  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/53418
+	* gcc.c-torture/compile/pr53418-1.c,
+	gcc.c-torture/compile/pr53418-2.c: New tests.
+
+2012-05-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2012-05-21  Uros Bizjak  <ubizjak@gmail.com>
+		    H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/53416
+	* gcc.target/i386/pr53416.c: New file.
+
+2012-05-14  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/avx256-unaligned-load-[1234].c: Update scan strings.
+	* gcc.target/i386/avx256-unaligned-store-[1234].c: Ditto.
+
+2012-05-03  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2012-05-03  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/53199
+	* gcc.target/powwerpc/pr53199.c: New file.
+
+2012-05-02  Tobias Burnus  <burnus@net-b.de>
+
+	Backport from mainline
+	2012-04-16  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/52864
+	* gfortran.dg/pointer_intent_6.f90: New.
+
+2012-04-30  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2012-04-27  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR target/53138
+	* gcc.c-torture/execute/20120427-1.c: New testcase.
+
+2012-04-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/53084
+	* gcc.c-torture/execute/pr53084.c: New test.
+
+2012-04-13  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2012-04-12  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/52775
+	* gcc.target/powerpc/pr52775.c: New file.
+
+2012-04-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/52796
+	* g++.dg/cpp0x/variadic-value1.C: New.
+
+2012-03-28  Joey Ye  <joey.ye@arm.com>
+
+	Backported from mainline
+	2011-12-20  Bernd Schmidt  <bernds@codesourcery.com>
+
+	PR middle-end/51200
+	* gcc.target/arm/volatile-bitfields-4.c: New test.
+	* c-c++-common/abi-bf.c: New test.
+
+	2011-12-26  Joey Ye  <joey.ye@arm.com>
+
+	PR middle-end/51200
+	* gcc.dg/volatile-bitfields-2.c: New test.
+
+2012-03-28  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from mainline
+	2012-03-27  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/52693
+	* gcc.dg/torture/pr52693.c: New test.
+
+2012-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/52736
+	* gcc.target/i386/pr52736.c: New test.
+
+2012-03-24  Jan Hubicka  <jh@suse.cz>
+
+	PR middle-end/51737
+	* g++.dg/torture/pr51737.C: New testcase
+
+2012-03-24  Steven Bosscher  <steven@gcc.gnu.org>
+
+	PR middle-end/52640
+	* gcc.c-torture/compile/limits-externdecl.c: New test.
+
+2012-03-16  Jan Hubicka  <jh@suse.cz>
+
+	PR middle-end/48600
+	* g++.dg/torture/pr48600.C: New testcase.
+
+2012-03-10  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/52469
+	* gfortran.dg/proc_ptr_34.f90: New.
+
+2012-03-06  Tobias Burnus  <burnus@net-b.de>
+
+	Backport from mainline
+	2012-03-02  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/52452
+	* gfortran.dg/intrinsic_8.f90: New.
+
+2012-03-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2012-03-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* gcc.target/powerpc/pr52457.c: New test.
+
 2012-03-01  Release Manager
 
 	* GCC 4.6.3 released.
Index: gcc/testsuite/g++.dg/cpp0x/variadic-value1.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/variadic-value1.C	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/g++.dg/cpp0x/variadic-value1.C	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,24 @@
+// PR c++/52796
+// { dg-options "-std=c++0x -pedantic-errors" }
+
+inline void *operator new(__SIZE_TYPE__ s, void *p) { return p; }
+
+struct A
+{
+  int i;
+  template<class... Ts>
+  A(Ts&&... ts): i(ts...) { }
+};
+
+static union {
+  unsigned char c[sizeof(A)];
+  int i;
+};
+
+int main()
+{
+  i = 0xdeadbeef;
+  new(c) A;
+  if (i != 0)
+    __builtin_abort();
+}
Index: gcc/testsuite/g++.dg/cpp0x/nullptr28.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/nullptr28.C	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/g++.dg/cpp0x/nullptr28.C	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,17 @@
+// { dg-do run }
+// { dg-options "-std=c++0x -pedantic-errors" }
+
+typedef decltype(nullptr) nullptr_t;
+
+int i;
+nullptr_t n;
+const nullptr_t& f() { ++i; return n; }
+
+nullptr_t g() { return f(); }
+
+int main()
+{
+  g();
+  if (i != 1)
+    __builtin_abort ();
+}
Index: gcc/testsuite/c-c++-common/abi-bf.c
===================================================================
--- gcc/testsuite/c-c++-common/abi-bf.c	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/testsuite/c-c++-common/abi-bf.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,3 @@
+/* { dg-warning "incompatible" } */
+/* { dg-do compile } */
+/* { dg-options "-fstrict-volatile-bitfields -fabi-version=1" } */
Index: gcc/cp/typeck.c
===================================================================
--- gcc/cp/typeck.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/cp/typeck.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1822,7 +1822,7 @@
   if (error_operand_p (exp))
     return error_mark_node;
 
-  if (NULLPTR_TYPE_P (type))
+  if (NULLPTR_TYPE_P (type) && !TREE_SIDE_EFFECTS (exp))
     return nullptr_node;
 
   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.
Index: gcc/cp/decl.c
===================================================================
--- gcc/cp/decl.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/cp/decl.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -3636,7 +3636,7 @@
     TYPE_SIZE_UNIT (nullptr_type_node) = size_int (GET_MODE_SIZE (ptr_mode));
     TYPE_UNSIGNED (nullptr_type_node) = 1;
     TYPE_PRECISION (nullptr_type_node) = GET_MODE_BITSIZE (ptr_mode);
-    SET_TYPE_MODE (nullptr_type_node, Pmode);
+    SET_TYPE_MODE (nullptr_type_node, ptr_mode);
     record_builtin_type (RID_MAX, "decltype(nullptr)", nullptr_type_node);
     nullptr_node = build_int_cst (nullptr_type_node, 0);
   }
Index: gcc/cp/ChangeLog
===================================================================
--- gcc/cp/ChangeLog	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/cp/ChangeLog	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,3 +1,20 @@
+2012-06-25  Jason Merrill  <jason@redhat.com>
+
+	PR c++/52988
+	* typeck.c (decay_conversion): Don't discard side-effects from
+	expressions of nullptr_t.
+
+2012-04-04  Steve Ellcey <sje@cup.hp.com>
+
+	Backported from mainline.
+	* decl.c (cxx_init_decl_processing): Use ptr_mode instead of Pmode.
+
+2012-04-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/52796
+	* pt.c (tsubst_initializer_list): A pack expansion with no elements
+	means value-initialization.
+
 2012-03-01  Release Manager
 
 	* GCC 4.6.3 released.
Index: gcc/cp/pt.c
===================================================================
--- gcc/cp/pt.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/cp/pt.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -17785,6 +17785,7 @@
             }
           else
             {
+	      tree tmp;
               decl = tsubst_copy (TREE_PURPOSE (t), argvec, 
                                   tf_warning_or_error, NULL_TREE);
 
@@ -17793,10 +17794,17 @@
                 in_base_initializer = 1;
 
 	      init = TREE_VALUE (t);
+	      tmp = init;
 	      if (init != void_type_node)
 		init = tsubst_expr (init, argvec,
 				    tf_warning_or_error, NULL_TREE,
 				    /*integral_constant_expression_p=*/false);
+	      if (init == NULL_TREE && tmp != NULL_TREE)
+		/* If we had an initializer but it instantiated to nothing,
+		   value-initialize the object.  This will only occur when
+		   the initializer was a pack expansion where the parameter
+		   packs used in that expansion were of length zero.  */
+		init = void_type_node;
               in_base_initializer = 0;
             }
 
Index: gcc/cp/semantics.c
===================================================================
--- gcc/cp/semantics.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/cp/semantics.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -6763,7 +6763,6 @@
 
   STRIP_NOPS (sub);
   subtype = TREE_TYPE (sub);
-  gcc_assert (POINTER_TYPE_P (subtype));
 
   if (TREE_CODE (sub) == ADDR_EXPR)
     {
Index: gcc/tree-ssa-ccp.c
===================================================================
--- gcc/tree-ssa-ccp.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/tree-ssa-ccp.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1364,6 +1364,10 @@
       if (!DECL_INITIAL (base)
 	  && (TREE_STATIC (base) || DECL_EXTERNAL (base)))
         return error_mark_node;
+      /* Do not return an error_mark_node DECL_INITIAL.  LTO uses this
+	 as special marker (_not_ zero ...) for its own purposes.  */
+      if (DECL_INITIAL (base) == error_mark_node)
+	return NULL_TREE;
       return DECL_INITIAL (base);
 
     case ARRAY_REF:
Index: gcc/expr.c
===================================================================
--- gcc/expr.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/expr.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -5971,6 +5971,8 @@
 		|| bitpos % GET_MODE_ALIGNMENT (mode))
 	       && SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (target)))
 	      || (bitpos % BITS_PER_UNIT != 0)))
+      || (bitsize >= 0 && mode != BLKmode
+	  && GET_MODE_BITSIZE (mode) > bitsize)
       /* If the RHS and field are a constant size and the size of the
 	 RHS isn't the same size as the bitfield, we must use bitfield
 	 operations.  */
@@ -9182,6 +9184,7 @@
 	orig_op0 = op0
 	  = expand_expr (tem,
 			 (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE
+			  && COMPLETE_TYPE_P (TREE_TYPE (tem))
 			  && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))
 			      != INTEGER_CST)
 			  && modifier != EXPAND_STACK_PARM
Index: gcc/gcov-iov.c
===================================================================
--- gcc/gcov-iov.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/gcov-iov.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -19,8 +19,8 @@
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
-#include <stdio.h>
-#include <stdlib.h>
+#include "bconfig.h"
+#include "system.h"
 
 /* Command line arguments are the base GCC version and the development
    phase (the latter may be an empty string).  */
@@ -48,8 +48,14 @@
   if (*ptr == '.')
     minor = strtoul (ptr + 1, 0, 10);
 
+  /* For releases the development phase is an empty string, for
+     prerelease versions on a release branch it is "prerelease".
+     Consider both equal as patch-level releases do not change
+     the GCOV version either.
+     On the trunk the development phase is "experimental".  */
   phase = argv[2][0];
-  if (phase == '\0')
+  if (phase == '\0'
+      || strcmp (argv[2], "prerelease") == 0)
     phase = '*';
 
   v[0] = (major < 10 ? '0' : 'A' - 10) + major;
Index: gcc/predict.c
===================================================================
--- gcc/predict.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/predict.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1790,7 +1790,8 @@
 static void
 predict_paths_for_bb (basic_block cur, basic_block bb,
 		      enum br_predictor pred,
-		      enum prediction taken)
+		      enum prediction taken,
+		      bitmap visited)
 {
   edge e;
   edge_iterator ei;
@@ -1811,7 +1812,7 @@
 	continue;
       gcc_assert (bb == cur || dominated_by_p (CDI_POST_DOMINATORS, cur, bb));
 
-      /* See if there is how many edge from e->src that is not abnormal
+      /* See if there is an edge from e->src that is not abnormal
 	 and does not lead to BB.  */
       FOR_EACH_EDGE (e2, ei2, e->src->succs)
 	if (e2 != e
@@ -1824,16 +1825,20 @@
 
       /* If there is non-abnormal path leaving e->src, predict edge
 	 using predictor.  Otherwise we need to look for paths
-	 leading to e->src.  */
+	 leading to e->src.
+
+	 The second may lead to infinite loop in the case we are predicitng
+	 regions that are only reachable by abnormal edges.  We simply
+	 prevent visiting given BB twice.  */
       if (found)
         predict_edge_def (e, pred, taken);
-      else
-	predict_paths_for_bb (e->src, e->src, pred, taken);
+      else if (bitmap_set_bit (visited, e->src->index))
+	predict_paths_for_bb (e->src, e->src, pred, taken, visited);
     }
   for (son = first_dom_son (CDI_POST_DOMINATORS, cur);
        son;
        son = next_dom_son (CDI_POST_DOMINATORS, son))
-    predict_paths_for_bb (son, bb, pred, taken);
+    predict_paths_for_bb (son, bb, pred, taken, visited);
 }
 
 /* Sets branch probabilities according to PREDiction and
@@ -1843,7 +1848,9 @@
 predict_paths_leading_to (basic_block bb, enum br_predictor pred,
 			  enum prediction taken)
 {
-  predict_paths_for_bb (bb, bb, pred, taken);
+  bitmap visited = BITMAP_ALLOC (NULL);
+  predict_paths_for_bb (bb, bb, pred, taken, visited);
+  BITMAP_FREE (visited);
 }
 
 /* Like predict_paths_leading_to but take edge instead of basic block.  */
@@ -1866,7 +1873,11 @@
 	break;
       }
   if (!has_nonloop_edge)
-    predict_paths_for_bb (bb, bb, pred, taken);
+    {
+      bitmap visited = BITMAP_ALLOC (NULL);
+      predict_paths_for_bb (bb, bb, pred, taken, visited);
+      BITMAP_FREE (visited);
+    }
   else
     predict_edge_def (e, pred, taken);
 }
Index: gcc/ada/ChangeLog
===================================================================
--- gcc/ada/ChangeLog	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/ada/ChangeLog	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,3 +1,12 @@
+2012-05-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (variant_desc): Rename 'record' to 'new_type'.
+	(build_variant_list): Adjust to above renaming.
+	(gnat_to_gnu_entity) <E_Record_Subtype>: Likewise.  Give a unique name
+	to the type of the variant containers.
+	(create_variant_part_from): Likewise.  Give a unique name to the type
+	of the variant part.
+
 2012-03-01  Release Manager
 
 	* GCC 4.6.3 released.
Index: gcc/ada/gcc-interface/decl.c
===================================================================
--- gcc/ada/gcc-interface/decl.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/ada/gcc-interface/decl.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -120,8 +120,8 @@
   /* The value of the qualifier.  */
   tree qual;
 
-  /* The record associated with this variant.  */
-  tree record;
+  /* The type of the variant after transformation.  */
+  tree new_type;
 } variant_desc;
 
 DEF_VEC_O(variant_desc);
@@ -3157,11 +3157,16 @@
 		      {
 			tree old_variant = v->type;
 			tree new_variant = make_node (RECORD_TYPE);
+			tree suffix
+			  = concat_name (DECL_NAME (gnu_variant_part),
+					 IDENTIFIER_POINTER
+					 (DECL_NAME (v->field)));
 			TYPE_NAME (new_variant)
-			  = DECL_NAME (TYPE_NAME (old_variant));
+			  = concat_name (TYPE_NAME (gnu_type),
+					 IDENTIFIER_POINTER (suffix));
 			copy_and_substitute_in_size (new_variant, old_variant,
 						     gnu_subst_list);
-			v->record = new_variant;
+			v->new_type = new_variant;
 		      }
 		}
 	      else
@@ -3265,7 +3270,7 @@
 			    if (selected_variant)
 			      gnu_cont_type = gnu_type;
 			    else
-			      gnu_cont_type = v->record;
+			      gnu_cont_type = v->new_type;
 			  }
 			else
 			  /* The front-end may pass us "ghost" components if
@@ -7704,7 +7709,7 @@
 	  v->type = variant_type;
 	  v->field = gnu_field;
 	  v->qual = qual;
-	  v->record = NULL_TREE;
+	  v->new_type = NULL_TREE;
 
 	  /* Recurse on the variant subpart of the variant, if any.  */
 	  variant_subpart = get_variant_part (variant_type);
@@ -8457,7 +8462,9 @@
 
   /* First create the type of the variant part from that of the old one.  */
   new_union_type = make_node (QUAL_UNION_TYPE);
-  TYPE_NAME (new_union_type) = DECL_NAME (TYPE_NAME (old_union_type));
+  TYPE_NAME (new_union_type)
+    = concat_name (TYPE_NAME (record_type),
+		   IDENTIFIER_POINTER (DECL_NAME (old_variant_part)));
 
   /* If the position of the variant part is constant, subtract it from the
      size of the type of the parent to get the new size.  This manual CSE
@@ -8491,7 +8498,7 @@
 	continue;
 
       /* Retrieve the list of fields already added to the new variant.  */
-      new_variant = v->record;
+      new_variant = v->new_type;
       field_list = TYPE_FIELDS (new_variant);
 
       /* If the old variant had a variant subpart, we need to create a new
Index: gcc/fortran/trans-array.c
===================================================================
--- gcc/fortran/trans-array.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/fortran/trans-array.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -2056,6 +2056,11 @@
   gfc_se se;
   int n;
 
+  /* Don't evaluate the arguments for realloc_lhs_loop_for_fcn_call; otherwise,
+     arguments could get evaluated multiple times.  */
+  if (ss->is_alloc_lhs)
+    return;
+
   /* TODO: This can generate bad code if there are ordering dependencies,
      e.g., a callee allocated function and an unknown size constructor.  */
   gcc_assert (ss != NULL);
@@ -7548,7 +7553,7 @@
   scalar = 1;
   for (; arg; arg = arg->next)
     {
-      if (!arg->expr)
+      if (!arg->expr || arg->expr->expr_type == EXPR_NULL)
 	continue;
 
       newss = gfc_walk_subexpr (head, arg->expr);
Index: gcc/fortran/decl.c
===================================================================
--- gcc/fortran/decl.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/fortran/decl.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -3623,8 +3623,9 @@
 	}
     }
 
-  /* Module variables implicitly have the SAVE attribute.  */
-  if (gfc_current_state () == COMP_MODULE && !current_attr.save)
+  /* Since Fortran 2008 module variables implicitly have the SAVE attribute.  */
+  if (gfc_current_state () == COMP_MODULE && !current_attr.save
+      && (gfc_option.allow_std & GFC_STD_F2008) != 0)
     current_attr.save = SAVE_IMPLICIT;
 
   colon_seen = 1;
Index: gcc/fortran/ChangeLog
===================================================================
--- gcc/fortran/ChangeLog	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/fortran/ChangeLog	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,3 +1,60 @@
+2012-07-14  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backport from trunk:
+	2012-01-09  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/51758
+	* trans-array.c (gfc_walk_elemental_function_args):
+	Skip over NULL() actual arguments.
+
+2012-06-14  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/53597
+	* decl.c (match_attr_spec): Only mark module variables
+	as SAVE_IMPLICIT for Fortran 2008 and later.
+
+2012-06-05  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50619
+	* resolve.c (build_default_init_expr): Don't initialize
+	ASSOCIATE names.
+
+2012-06-01  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/53521
+	* trans.c (gfc_deallocate_scalar_with_status): Properly
+	handle the case size == 0.
+
+2012-05-23  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/53389
+	* trans-array.c (gfc_add_loop_ss_code): Don't evaluate
+	expression, if ss->is_alloc_lhs is set.
+
+2012-05-02  Tobias Burnus  <burnus@net-b.de>
+
+	Backport from mainline
+	2012-04-12  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/52864
+	* expr.c (gfc_check_vardef_context): Fix assignment check for
+	pointer components.
+
+2012-03-10  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/52469
+	* trans-types.c (gfc_get_function_type): Handle backend_decl
+	of a procedure pointer.
+
+2012-03-06  Tobias Burnus  <burnus@net-b.de>
+
+	Backport from mainline
+	2012-03-02  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/52452
+	* resolve.c (resolve_intrinsic): Don't search for a
+	function if we know that it is a subroutine.
+
 2012-03-01  Release Manager
 
 	* GCC 4.6.3 released.
Index: gcc/fortran/expr.c
===================================================================
--- gcc/fortran/expr.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/fortran/expr.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -4474,7 +4474,11 @@
       if (ptr_component && ref->type == REF_COMPONENT)
 	check_intentin = false;
       if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)
-	ptr_component = true;
+	{
+	  ptr_component = true;
+	  if (!pointer)
+	    check_intentin = false;
+	}
     }
   if (check_intentin && sym->attr.intent == INTENT_IN)
     {
Index: gcc/fortran/trans.c
===================================================================
--- gcc/fortran/trans.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/fortran/trans.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1005,15 +1005,12 @@
   if (!res && size != 0)
     _gfortran_os_error ("Allocation would exceed memory limit");
 
-  if (size == 0)
-    return NULL;
-
   return res;
 }  */
 tree
 gfc_call_realloc (stmtblock_t * block, tree mem, tree size)
 {
-  tree msg, res, nonzero, zero, null_result, tmp;
+  tree msg, res, nonzero, null_result, tmp;
   tree type = TREE_TYPE (mem);
 
   size = gfc_evaluate_now (size, block);
@@ -1044,15 +1041,6 @@
 			 build_empty_stmt (input_location));
   gfc_add_expr_to_block (block, tmp);
 
-  /* if (size == 0) then the result is NULL.  */
-  tmp = fold_build2_loc (input_location, MODIFY_EXPR, type, res,
-			 build_int_cst (type, 0));
-  zero = fold_build1_loc (input_location, TRUTH_NOT_EXPR, boolean_type_node,
-			  nonzero);
-  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, zero, tmp,
-			 build_empty_stmt (input_location));
-  gfc_add_expr_to_block (block, tmp);
-
   return res;
 }
 
Index: gcc/fortran/trans-types.c
===================================================================
--- gcc/fortran/trans-types.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/fortran/trans-types.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -2519,7 +2519,11 @@
 	      || sym->attr.flavor == FL_PROGRAM);
 
   if (sym->backend_decl)
-    return TREE_TYPE (sym->backend_decl);
+    {
+      if (sym->attr.proc_pointer)
+	return TREE_TYPE (TREE_TYPE (sym->backend_decl));
+      return TREE_TYPE (sym->backend_decl);
+    }
 
   alternate_return = 0;
   typelist = NULL_TREE;
Index: gcc/fortran/resolve.c
===================================================================
--- gcc/fortran/resolve.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/fortran/resolve.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1452,7 +1452,7 @@
 
   if (sym->intmod_sym_id)
     isym = gfc_intrinsic_function_by_id ((gfc_isym_id) sym->intmod_sym_id);
-  else
+  else if (!sym->attr.subroutine)
     isym = gfc_find_function (sym->name);
 
   if (isym)
@@ -9700,7 +9700,8 @@
       || sym->attr.data
       || sym->module
       || sym->attr.cray_pointee
-      || sym->attr.cray_pointer)
+      || sym->attr.cray_pointer
+      || sym->assoc)
     return NULL;
 
   /* Now we'll try to build an initializer expression.  */
Index: gcc/BASE-VER
===================================================================
--- gcc/BASE-VER	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/BASE-VER	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1 +1 @@
-4.6.3
+4.6.4
Index: gcc/stor-layout.c
===================================================================
--- gcc/stor-layout.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/stor-layout.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -660,12 +660,13 @@
 	  /* See if we can use an ordinary integer mode for a bit-field.
 	     Conditions are: a fixed size that is correct for another mode,
 	     occupying a complete byte or bytes on proper boundary,
-	     and not volatile or not -fstrict-volatile-bitfields.  */
+	     and not -fstrict-volatile-bitfields.  If the latter is set,
+	     we unfortunately can't check TREE_THIS_VOLATILE, as a cast
+	     may make a volatile object later.  */
 	  if (TYPE_SIZE (type) != 0
 	      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST
 	      && GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT
-	      && !(TREE_THIS_VOLATILE (decl)
-		   && flag_strict_volatile_bitfields > 0))
+	      && flag_strict_volatile_bitfields <= 0)
 	    {
 	      enum machine_mode xmode
 		= mode_for_size_tree (DECL_SIZE (decl), MODE_INT, 1);
Index: gcc/tree-vect-loop.c
===================================================================
--- gcc/tree-vect-loop.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/tree-vect-loop.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -2104,7 +2104,8 @@
           if (stmt_info
               && !STMT_VINFO_RELEVANT_P (stmt_info)
               && (!STMT_VINFO_LIVE_P (stmt_info)
-                  || STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def))
+                  || !VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info)))
+	      && !STMT_VINFO_IN_PATTERN_P (stmt_info))
             continue;
 
           if (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt)))
@@ -2251,11 +2252,19 @@
 	{
 	  gimple stmt = gsi_stmt (si);
 	  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);
+
+	  if (STMT_VINFO_IN_PATTERN_P (stmt_info))
+	    {
+	      stmt = STMT_VINFO_RELATED_STMT (stmt_info);
+	      stmt_info = vinfo_for_stmt (stmt);
+	    }
+
 	  /* Skip stmts that are not vectorized inside the loop.  */
 	  if (!STMT_VINFO_RELEVANT_P (stmt_info)
 	      && (!STMT_VINFO_LIVE_P (stmt_info)
-		  || STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def))
+		  || !VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info))))
 	    continue;
+
 	  vec_inside_cost += STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) * factor;
 	  /* FIXME: for stmts in the inner-loop in outer-loop vectorization,
 	     some of the "outside" costs are generated inside the outer-loop.  */
Index: gcc/c-typeck.c
===================================================================
--- gcc/c-typeck.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/c-typeck.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -4315,6 +4315,11 @@
     ret = fold_build3_loc (colon_loc, COND_EXPR, result_type, ifexp, op1, op2);
   else
     {
+      if (int_operands)
+	{
+	  op1 = remove_c_maybe_const_expr (op1);
+	  op2 = remove_c_maybe_const_expr (op2);
+	}
       ret = build3 (COND_EXPR, result_type, ifexp, op1, op2);
       if (int_operands)
 	ret = note_integer_operands (ret);
Index: gcc/tree-sra.c
===================================================================
--- gcc/tree-sra.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/tree-sra.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -2937,7 +2937,13 @@
     }
   else
     {
-      if (access_has_children_p (lacc) && access_has_children_p (racc))
+      if (access_has_children_p (lacc)
+	  && access_has_children_p (racc)
+	  /* When an access represents an unscalarizable region, it usually
+	     represents accesses with variable offset and thus must not be used
+	     to generate new memory accesses.  */
+	  && !lacc->grp_unscalarizable_region
+	  && !racc->grp_unscalarizable_region)
 	{
 	  gimple_stmt_iterator orig_gsi = *gsi;
 	  enum unscalarized_data_handling refreshed;
Index: gcc/lto/lto.c
===================================================================
--- gcc/lto/lto.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/lto/lto.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -893,7 +893,8 @@
 
   for (node = cgraph_nodes; node; node = node->next)
     {
-      if (!partition_cgraph_node_p (node))
+      if (!partition_cgraph_node_p (node)
+	  || node->aux)
 	continue;
 
       file_data = node->local.lto_file_data;
@@ -923,13 +924,13 @@
 	  npartitions++;
 	}
 
-      if (!node->aux)
-        add_cgraph_node_to_partition (partition, node);
+      add_cgraph_node_to_partition (partition, node);
     }
 
   for (vnode = varpool_nodes; vnode; vnode = vnode->next)
     {
-      if (!partition_varpool_node_p (vnode))
+      if (!partition_varpool_node_p (vnode)
+	  || vnode->aux)
 	continue;
       file_data = vnode->lto_file_data;
       slot = pointer_map_contains (pmap, file_data);
@@ -943,8 +944,7 @@
 	  npartitions++;
 	}
 
-      if (!vnode->aux)
-        add_varpool_node_to_partition (partition, vnode);
+      add_varpool_node_to_partition (partition, vnode);
     }
   for (node = cgraph_nodes; node; node = node->next)
     node->aux = NULL;
@@ -1050,8 +1050,9 @@
 
   for (i = 0; i < n_nodes; i++)
     {
-      if (!order[i]->aux)
-        add_cgraph_node_to_partition (partition, order[i]);
+      if (order[i]->aux)
+	continue;
+      add_cgraph_node_to_partition (partition, order[i]);
       total_size -= order[i]->global.size;
 
       /* Once we added a new node to the partition, we also want to add
@@ -1231,6 +1232,8 @@
 	    }
 	  i = best_i;
  	  /* When we are finished, avoid creating empty partition.  */
+	  while (i < n_nodes - 1 && order[i + 1]->aux)
+	    i++;
 	  if (i == n_nodes - 1)
 	    break;
 	  partition = new_partition ("");
Index: gcc/lto/ChangeLog
===================================================================
--- gcc/lto/ChangeLog	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/lto/ChangeLog	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,3 +1,12 @@
+2012-04-23  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2011-06-11  Jan Hubicka  <jh@suse.cz>
+
+	PR lto/48246
+	* lto.c (lto_1_to_1_map): Don't create empty partitions.
+	(lto_balanced_map): Likewise.
+
 2012-03-01  Release Manager
 
 	* GCC 4.6.3 released.
Index: gcc/ipa-prop.c
===================================================================
--- gcc/ipa-prop.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/ipa-prop.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -704,12 +704,11 @@
       || is_global_var (base))
     return;
 
-  if (detect_type_change (op, base, call, jfunc, offset))
+  binfo = TYPE_BINFO (TREE_TYPE (base));
+  if (!binfo
+      || detect_type_change (op, base, call, jfunc, offset))
     return;
 
-  binfo = TYPE_BINFO (TREE_TYPE (base));
-  if (!binfo)
-    return;
   binfo = get_binfo_at_offset (binfo, offset, TREE_TYPE (op));
   if (binfo)
     {
Index: gcc/varasm.c
===================================================================
--- gcc/varasm.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/varasm.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,7 +1,7 @@
 /* Output variables, constants and external declarations, for GNU compiler.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,
    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
-   2010, 2011  Free Software Foundation, Inc.
+   2010, 2011, 2012  Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -30,6 +30,7 @@
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
+#include "pointer-set.h"
 #include "tm.h"
 #include "rtl.h"
 #include "tree.h"
@@ -2097,6 +2098,19 @@
    it all the way to final.  See PR 17982 for further discussion.  */
 static GTY(()) tree pending_assemble_externals;
 
+/* FIXME: Trunk is at GCC 4.8 now and the above problem still hasn't been
+   addressed properly.  This caused PR 52640 due to O(external_decls**2)
+   lookups in the pending_assemble_externals TREE_LIST in assemble_external.
+   Paper over with this pointer set, which we use to see if we have already
+   added a decl to pending_assemble_externals without first traversing
+   the entire pending_assemble_externals list.  See assemble_external().  */
+static struct pointer_set_t *pending_assemble_externals_set;
+
+/* Some targets delay some output to final using TARGET_ASM_FILE_END.
+   As a result, assemble_external can be called after the list of externals
+   is processed and the pointer set destroyed.  */
+static bool pending_assemble_externals_processed;
+
 #ifdef ASM_OUTPUT_EXTERNAL
 /* True if DECL is a function decl for which no out-of-line copy exists.
    It is assumed that DECL's assembler name has been set.  */
@@ -2146,6 +2160,8 @@
     assemble_external_real (TREE_VALUE (list));
 
   pending_assemble_externals = 0;
+  pending_assemble_externals_processed = true;
+  pointer_set_destroy (pending_assemble_externals_set);
 #endif
 }
 
@@ -2186,7 +2202,13 @@
     weak_decls = tree_cons (NULL, decl, weak_decls);
 
 #ifdef ASM_OUTPUT_EXTERNAL
-  if (value_member (decl, pending_assemble_externals) == NULL_TREE)
+  if (pending_assemble_externals_processed)
+    {
+      assemble_external_real (decl);
+      return;
+    }
+
+  if (! pointer_set_insert (pending_assemble_externals_set, decl))
     pending_assemble_externals = tree_cons (NULL, decl,
 					    pending_assemble_externals);
 #endif
@@ -3922,6 +3944,13 @@
 	   tem = TREE_OPERAND (tem, 0))
 	;
 
+      if (TREE_CODE (tem) == MEM_REF
+	  && TREE_CODE (TREE_OPERAND (tem, 0)) == ADDR_EXPR)
+	{
+	  reloc = compute_reloc_for_constant (TREE_OPERAND (tem, 0));
+	  break;
+	}
+
       if (TREE_PUBLIC (tem))
 	reloc |= 2;
       else
@@ -3990,6 +4019,9 @@
 
       if (CONSTANT_CLASS_P (tem) || TREE_CODE (tem) == CONSTRUCTOR)
 	output_constant_def (tem, 0);
+
+      if (TREE_CODE (tem) == MEM_REF)
+	output_addressed_constants (TREE_OPERAND (tem, 0));
       break;
 
     case PLUS_EXPR:
@@ -6019,6 +6051,10 @@
 
   if (readonly_data_section == NULL)
     readonly_data_section = text_section;
+
+#ifdef ASM_OUTPUT_EXTERNAL
+  pending_assemble_externals_set = pointer_set_create ();
+#endif
 }
 
 enum tls_model
Index: gcc/tree-vect-stmts.c
===================================================================
--- gcc/tree-vect-stmts.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/tree-vect-stmts.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -623,6 +623,46 @@
 }
 
 
+/* Model cost for type demotion and promotion operations.  PWR is normally
+   zero for single-step promotions and demotions.  It will be one if 
+   two-step promotion/demotion is required, and so on.  Each additional
+   step doubles the number of instructions required.  */
+
+static void
+vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,
+				    enum vect_def_type *dt, int pwr)
+{
+  int i, tmp;
+  int inside_cost = 0, outside_cost = 0, single_stmt_cost;
+
+  /* The SLP costs were already calculated during SLP tree build.  */
+  if (PURE_SLP_STMT (stmt_info))
+    return;
+
+  single_stmt_cost = vect_get_stmt_cost (vec_promote_demote);
+  for (i = 0; i < pwr + 1; i++)
+    {
+      tmp = (STMT_VINFO_TYPE (stmt_info) == type_promotion_vec_info_type) ?
+	(i + 1) : i;
+      inside_cost += vect_pow2 (tmp) * single_stmt_cost;
+    }
+
+  /* FORNOW: Assuming maximum 2 args per stmts.  */
+  for (i = 0; i < 2; i++)
+    {
+      if (dt[i] == vect_constant_def || dt[i] == vect_external_def)
+        outside_cost += vect_get_stmt_cost (vector_stmt);
+    }
+
+  if (vect_print_dump_info (REPORT_COST))
+    fprintf (vect_dump, "vect_model_promotion_demotion_cost: inside_cost = %d, "
+             "outside_cost = %d .", inside_cost, outside_cost);
+
+  /* Set the costs in STMT_INFO.  */
+  stmt_vinfo_set_inside_of_loop_cost (stmt_info, NULL, inside_cost);
+  stmt_vinfo_set_outside_of_loop_cost (stmt_info, NULL, outside_cost);
+}
+
 /* Function vect_cost_strided_group_size
 
    For strided load or store, return the group_size only if it is the first
@@ -691,7 +731,7 @@
     {
       /* Uses a high and low interleave operation for each needed permute.  */
       inside_cost = ncopies * exact_log2(group_size) * group_size
-        * vect_get_stmt_cost (vector_stmt);
+        * vect_get_stmt_cost (vec_perm);
 
       if (vect_print_dump_info (REPORT_COST))
         fprintf (vect_dump, "vect_model_store_cost: strided group_size = %d .",
@@ -795,7 +835,7 @@
     {
       /* Uses an even and odd extract operations for each needed permute.  */
       inside_cost = ncopies * exact_log2(group_size) * group_size
-	* vect_get_stmt_cost (vector_stmt);
+	* vect_get_stmt_cost (vec_perm);
 
       if (vect_print_dump_info (REPORT_COST))
         fprintf (vect_dump, "vect_model_load_cost: strided group_size = %d .",
@@ -855,7 +895,7 @@
     case dr_explicit_realign:
       {
         *inside_cost += ncopies * (2 * vect_get_stmt_cost (vector_load)
-           + vect_get_stmt_cost (vector_stmt));
+				   + vect_get_stmt_cost (vec_perm));
 
         /* FIXME: If the misalignment remains fixed across the iterations of
            the containing loop, the following cost should be added to the
@@ -863,6 +903,9 @@
         if (targetm.vectorize.builtin_mask_for_load)
           *inside_cost += vect_get_stmt_cost (vector_stmt);
 
+        if (vect_print_dump_info (REPORT_COST))
+          fprintf (vect_dump, "vect_model_load_cost: explicit realign");
+
         break;
       }
     case dr_explicit_realign_optimized:
@@ -886,7 +929,12 @@
           }
 
         *inside_cost += ncopies * (vect_get_stmt_cost (vector_load)
-          + vect_get_stmt_cost (vector_stmt));
+				   + vect_get_stmt_cost (vec_perm));
+
+        if (vect_print_dump_info (REPORT_COST))
+          fprintf (vect_dump,
+		   "vect_model_load_cost: explicit realign optimized");
+
         break;
       }
 
@@ -2919,7 +2967,7 @@
       STMT_VINFO_TYPE (stmt_info) = type_demotion_vec_info_type;
       if (vect_print_dump_info (REPORT_DETAILS))
         fprintf (vect_dump, "=== vectorizable_demotion ===");
-      vect_model_simple_cost (stmt_info, ncopies, dt, NULL);
+      vect_model_promotion_demotion_cost (stmt_info, dt, multi_step_cvt);
       return true;
     }
 
@@ -3217,7 +3265,7 @@
       STMT_VINFO_TYPE (stmt_info) = type_promotion_vec_info_type;
       if (vect_print_dump_info (REPORT_DETAILS))
         fprintf (vect_dump, "=== vectorizable_promotion ===");
-      vect_model_simple_cost (stmt_info, 2*ncopies, dt, NULL);
+      vect_model_promotion_demotion_cost (stmt_info, dt, multi_step_cvt);
       return true;
     }
 
Index: gcc/tree-inline.c
===================================================================
--- gcc/tree-inline.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/tree-inline.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -4947,7 +4947,7 @@
 	        if ((e = cgraph_edge (id->dst_node, gsi_stmt (bsi))) != NULL)
 		  {
 		    if (!e->inline_failed)
-		      cgraph_remove_node_and_inline_clones (e->callee);
+		      cgraph_remove_node_and_inline_clones (e->callee, id->dst_node);
 		    else
 	              cgraph_remove_edge (e);
 		  }
@@ -4957,8 +4957,8 @@
 		    {
 	              if ((e = cgraph_edge (node, gsi_stmt (bsi))) != NULL)
 			{
-		          if (!e->inline_failed)
-		            cgraph_remove_node_and_inline_clones (e->callee);
+		          if (!e->inline_failed && e->callee != id->src_node)
+		            cgraph_remove_node_and_inline_clones (e->callee, id->dst_node);
 			  else
 	                    cgraph_remove_edge (e);
 			}
Index: gcc/combine.c
===================================================================
--- gcc/combine.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/combine.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1788,6 +1788,10 @@
   if (set == 0)
     return 0;
 
+  /* The simplification in expand_field_assignment may call back to
+     get_last_value, so set safe guard here.  */
+  subst_low_luid = DF_INSN_LUID (insn);
+
   set = expand_field_assignment (set);
   src = SET_SRC (set), dest = SET_DEST (set);
 
Index: gcc/df-problems.c
===================================================================
--- gcc/df-problems.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/df-problems.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -3956,6 +3956,19 @@
   df_simulate_initialize_backwards (merge_bb, test_use);
   for (insn = across_to; ; insn = next)
     {
+      if (CALL_P (insn))
+	{
+	  if (RTL_CONST_OR_PURE_CALL_P (insn))
+	    /* Pure functions can read from memory.  Const functions can
+	       read from arguments that the ABI has forced onto the stack.
+	       Neither sort of read can be volatile.  */
+	    memrefs_in_across |= MEMREF_NORMAL;
+	  else
+	    {
+	      memrefs_in_across |= MEMREF_VOLATILE;
+	      mem_sets_in_across |= MEMREF_VOLATILE;
+	    }
+	}
       if (NONDEBUG_INSN_P (insn))
 	{
 	  df_simulate_find_defs (insn, test_set);
Index: gcc/config.gcc
===================================================================
--- gcc/config.gcc	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config.gcc	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -817,7 +817,7 @@
 arm*-*-linux*)			# ARM GNU/Linux with ELF
 	tm_file="dbxelf.h elfos.h gnu-user.h linux.h linux-android.h glibc-stdint.h arm/elf.h arm/linux-gas.h arm/linux-elf.h"
 	case $target in
-	arm*b-*)
+	arm*b-*-linux*)
 		tm_defines="${tm_defines} TARGET_BIG_ENDIAN_DEFAULT=1"
 		;;
 	esac
@@ -925,7 +925,7 @@
 	extra_objs="avr-devices.o"
 	;;
 avr-*-*)
-	tm_file="avr/avr.h dbxelf.h newlib-stdint.h"
+	tm_file="avr/avr.h dbxelf.h avr/avr-stdint.h"
 	use_gcc_stdint=wrap
 	extra_gcc_objs="driver-avr.o avr-devices.o"
 	extra_objs="avr-devices.o"
Index: gcc/gimple.c
===================================================================
--- gcc/gimple.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/gimple.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -2275,8 +2275,6 @@
 bool
 gimple_has_side_effects (const_gimple s)
 {
-  unsigned i;
-
   if (is_gimple_debug (s))
     return false;
 
@@ -2292,45 +2290,15 @@
 
   if (is_gimple_call (s))
     {
-      unsigned nargs = gimple_call_num_args (s);
+      int flags = gimple_call_flags (s);
 
-      if (!(gimple_call_flags (s) & (ECF_CONST | ECF_PURE)))
-        return true;
-      else if (gimple_call_flags (s) & ECF_LOOPING_CONST_OR_PURE)
-	/* An infinite loop is considered a side effect.  */
+      /* An infinite loop is considered a side effect.  */
+      if (!(flags & (ECF_CONST | ECF_PURE))
+	  || (flags & ECF_LOOPING_CONST_OR_PURE))
 	return true;
 
-      if (gimple_call_lhs (s)
-          && TREE_SIDE_EFFECTS (gimple_call_lhs (s)))
-	{
-	  gcc_checking_assert (gimple_has_volatile_ops (s));
-	  return true;
-	}
-
-      if (TREE_SIDE_EFFECTS (gimple_call_fn (s)))
-        return true;
-
-      for (i = 0; i < nargs; i++)
-        if (TREE_SIDE_EFFECTS (gimple_call_arg (s, i)))
-	  {
-	    gcc_checking_assert (gimple_has_volatile_ops (s));
-	    return true;
-	  }
-
       return false;
     }
-  else
-    {
-      for (i = 0; i < gimple_num_ops (s); i++)
-	{
-	  tree op = gimple_op (s, i);
-	  if (op && TREE_SIDE_EFFECTS (op))
-	    {
-	      gcc_checking_assert (gimple_has_volatile_ops (s));
-	      return true;
-	    }
-	}
-    }
 
   return false;
 }
Index: gcc/gthr-posix.h
===================================================================
--- gcc/gthr-posix.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/gthr-posix.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -239,16 +239,15 @@
 static inline int
 __gthread_active_p (void)
 {
-  static void *const __gthread_active_ptr
-    = __extension__ (void *) &__gthrw_(
 /* Android's C library does not provide pthread_cancel, check for
    `pthread_create' instead.  */
 #ifndef __BIONIC__
-				       pthread_cancel
+  static void *const __gthread_active_ptr
+    = __extension__ (void *) &__gthrw_(pthread_cancel);
 #else
-				       pthread_create
+  static void *const __gthread_active_ptr
+    = __extension__ (void *) &__gthrw_(pthread_create);
 #endif
-				       );
   return __gthread_active_ptr != 0;
 }
 
Index: gcc/config/alpha/linux-unwind.h
===================================================================
--- gcc/config/alpha/linux-unwind.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/alpha/linux-unwind.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for Alpha Linux.
-   Copyright (C) 2004, 2005, 2009, 2011 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2009, 2011, 2012 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -49,7 +49,7 @@
   else if (pc[1] == 0x201f015f)		/* lda $0,NR_rt_sigreturn */
     {
       struct rt_sigframe {
-	struct siginfo info;
+	siginfo_t info;
 	struct ucontext uc;
       } *rt_ = context->cfa;
       sc = &rt_->uc.uc_mcontext;
Index: gcc/config/alpha/alpha.c
===================================================================
--- gcc/config/alpha/alpha.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/alpha/alpha.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -2469,7 +2469,7 @@
     {
     case EQ:  case LE:  case LT:  case LEU:  case LTU:
     case UNORDERED:
-      /* We have these compares: */
+      /* We have these compares.  */
       cmp_code = code, branch_code = NE;
       break;
 
@@ -2706,13 +2706,15 @@
       switch (code)
 	{
 	case EQ: case LE: case LT: case LEU: case LTU:
+	case UNORDERED:
 	  /* We have these compares.  */
 	  cmp_code = code, code = NE;
 	  break;
 
 	case NE:
-	  /* This must be reversed.  */
-	  cmp_code = EQ, code = EQ;
+	case ORDERED:
+	  /* These must be reversed.  */
+	  cmp_code = reverse_condition (code), code = EQ;
 	  break;
 
 	case GE: case GT: case GEU: case GTU:
@@ -2732,6 +2734,14 @@
 	  gcc_unreachable ();
 	}
 
+      if (cmp_mode == DImode)
+	{
+	  if (!reg_or_0_operand (op0, DImode))
+	    op0 = force_reg (DImode, op0);
+	  if (!reg_or_8bit_operand (op1, DImode))
+	    op1 = force_reg (DImode, op1);
+	}
+
       tem = gen_reg_rtx (cmp_mode);
       emit_insn (gen_rtx_SET (VOIDmode, tem,
 			      gen_rtx_fmt_ee (cmp_code, cmp_mode,
@@ -2743,6 +2753,14 @@
       local_fast_math = 1;
     }
 
+  if (cmp_mode == DImode)
+    {
+      if (!reg_or_0_operand (op0, DImode))
+	op0 = force_reg (DImode, op0);
+      if (!reg_or_8bit_operand (op1, DImode))
+	op1 = force_reg (DImode, op1);
+    }
+
   /* We may be able to use a conditional move directly.
      This avoids emitting spurious compares.  */
   if (signed_comparison_operator (cmp, VOIDmode)
@@ -2761,11 +2779,13 @@
   switch (code)
     {
     case EQ:  case LE:  case LT:  case LEU:  case LTU:
+    case UNORDERED:
       /* We have these compares: */
       break;
 
     case NE:
-      /* This must be reversed.  */
+    case ORDERED:
+      /* These must be reversed.  */
       code = reverse_condition (code);
       cmov_code = EQ;
       break;
Index: gcc/config/m32c/m32c.c
===================================================================
--- gcc/config/m32c/m32c.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/m32c/m32c.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -447,7 +447,7 @@
     flag_ivopts = 0;
 
   /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0)
+  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 
   /* r8c/m16c have no 16-bit indirect call, so thunks are involved.
Index: gcc/config/spu/spu.c
===================================================================
--- gcc/config/spu/spu.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/spu/spu.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -6794,6 +6794,7 @@
       case scalar_to_vec:
       case cond_branch_not_taken:
       case vec_perm:
+      case vec_promote_demote:
         return 1;
 
       case scalar_store:
Index: gcc/config/sparc/sparc.c
===================================================================
--- gcc/config/sparc/sparc.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/sparc/sparc.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -3658,13 +3658,17 @@
 {
   x = delegitimize_mem_from_attrs (x);
 
-  if (GET_CODE (x) == LO_SUM
-      && GET_CODE (XEXP (x, 1)) == UNSPEC
-      && XINT (XEXP (x, 1), 1) == UNSPEC_TLSLE)
-    {
-      x = XVECEXP (XEXP (x, 1), 0, 0);
-      gcc_assert (GET_CODE (x) == SYMBOL_REF);
-    }
+  if (GET_CODE (x) == LO_SUM && GET_CODE (XEXP (x, 1)) == UNSPEC)
+    switch (XINT (XEXP (x, 1), 1))
+      {
+      case UNSPEC_MOVE_PIC:
+      case UNSPEC_TLSLE:
+	x = XVECEXP (XEXP (x, 1), 0, 0);
+	gcc_assert (GET_CODE (x) == SYMBOL_REF);
+	break;
+      default:
+	break;
+      }
 
   return x;
 }
@@ -9634,6 +9638,7 @@
 						       void_list_node));
 	  DECL_RESULT (decl) = build_decl (BUILTINS_LOCATION, RESULT_DECL,
 					   NULL_TREE, void_type_node);
+	  TREE_PUBLIC (decl) = 1;
 	  TREE_STATIC (decl) = 1;
 	  make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));
 	  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;
Index: gcc/config/rx/rx.c
===================================================================
--- gcc/config/rx/rx.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/rx/rx.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -2348,7 +2348,7 @@
 rx_option_override (void)
 {
   /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0)
+  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 
   rx_override_options_after_change ();
Index: gcc/config/i386/i386.h
===================================================================
--- gcc/config/i386/i386.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/i386/i386.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -424,7 +424,7 @@
 
 /* Feature tests against the various architecture variations.  */
 enum ix86_arch_indices {
-  X86_ARCH_CMOVE,		/* || TARGET_SSE */
+  X86_ARCH_CMOV,
   X86_ARCH_CMPXCHG,
   X86_ARCH_CMPXCHG8B,
   X86_ARCH_XADD,
@@ -435,12 +435,17 @@
 
 extern unsigned char ix86_arch_features[X86_ARCH_LAST];
 
-#define TARGET_CMOVE		ix86_arch_features[X86_ARCH_CMOVE]
+#define TARGET_CMOV		ix86_arch_features[X86_ARCH_CMOV]
 #define TARGET_CMPXCHG		ix86_arch_features[X86_ARCH_CMPXCHG]
 #define TARGET_CMPXCHG8B	ix86_arch_features[X86_ARCH_CMPXCHG8B]
 #define TARGET_XADD		ix86_arch_features[X86_ARCH_XADD]
 #define TARGET_BSWAP		ix86_arch_features[X86_ARCH_BSWAP]
 
+/* For sane SSE instruction set generation we need fcomi instruction.
+   It is safe to enable all CMOVE instructions.  Also, RDRAND intrinsic
+   expands to a sequence that includes conditional move. */
+#define TARGET_CMOVE		(TARGET_CMOV || TARGET_SSE || TARGET_RDRND)
+
 #define TARGET_FISTTP		(TARGET_SSE3 && TARGET_80387)
 
 extern int x86_prefetch_sse;
@@ -1668,6 +1673,17 @@
 
 #define LEGITIMATE_CONSTANT_P(X)  legitimate_constant_p (X)
 
+/* Try a machine-dependent way of reloading an illegitimate address
+   operand.  If we find one, push the reload and jump to WIN.  This
+   macro is used in only one place: `find_reloads_address' in reload.c.  */
+
+#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, INDL, WIN)	\
+do {									\
+  if (ix86_legitimize_reload_address ((X), (MODE), (OPNUM),		\
+				      (int)(TYPE), (INDL)))		\
+    goto WIN;								\
+} while (0)
+
 /* If defined, a C expression to determine the base term of address X.
    This macro is used in only one place: `find_base_term' in alias.c.
 
Index: gcc/config/i386/i386.md
===================================================================
--- gcc/config/i386/i386.md	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/i386/i386.md	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -233,9 +233,6 @@
 
   ;; For BMI support
   UNSPEC_BEXTR
-
-  ;; For RDRAND support
-  UNSPEC_RDRAND
 ])
 
 (define_c_enum "unspecv" [
@@ -270,6 +267,9 @@
   UNSPECV_WRFSBASE
   UNSPECV_WRGSBASE
   UNSPECV_SPLIT_STACK_RETURN
+
+  ;; For RDRAND support
+  UNSPECV_RDRAND
 ])
 
 ;; Constants to represent pcomtrue/pcomfalse variants
@@ -16349,7 +16349,8 @@
 (define_insn "*x86_mov<mode>cc_0_m1_neg"
   [(set (match_operand:SWI48 0 "register_operand" "=r")
 	(neg:SWI48 (match_operator 1 "ix86_carry_flag_operator"
-		    [(reg FLAGS_REG) (const_int 0)])))]
+		    [(reg FLAGS_REG) (const_int 0)])))
+   (clobber (reg:CC FLAGS_REG))]
   ""
   "sbb{<imodesuffix>}\t%0, %0"
   [(set_attr "type" "alu")
@@ -18357,9 +18358,9 @@
 
 (define_insn "rdrand<mode>_1"
   [(set (match_operand:SWI248 0 "register_operand" "=r")
-	(unspec:SWI248 [(const_int 0)] UNSPEC_RDRAND))
+	(unspec_volatile:SWI248 [(const_int 0)] UNSPECV_RDRAND))
    (set (reg:CCC FLAGS_REG)
-	(unspec:CCC [(const_int 0)] UNSPEC_RDRAND))]
+	(unspec_volatile:CCC [(const_int 0)] UNSPECV_RDRAND))]
   "TARGET_RDRND"
   "rdrand\t%0"
   [(set_attr "type" "other")
Index: gcc/config/i386/sse.md
===================================================================
--- gcc/config/i386/sse.md	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/i386/sse.md	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -392,18 +392,7 @@
   DONE;
 })
 
-(define_expand "avx_movu<ssemodesuffix><avxmodesuffix>"
-  [(set (match_operand:AVXMODEF2P 0 "nonimmediate_operand" "")
-	(unspec:AVXMODEF2P
-	  [(match_operand:AVXMODEF2P 1 "nonimmediate_operand" "")]
-	  UNSPEC_MOVU))]
-  "AVX_VEC_FLOAT_MODE_P (<MODE>mode)"
-{
-  if (MEM_P (operands[0]) && MEM_P (operands[1]))
-    operands[1] = force_reg (<MODE>mode, operands[1]);
-})
-
-(define_insn "*avx_movu<ssemodesuffix><avxmodesuffix>"
+(define_insn "avx_movu<ssemodesuffix><avxmodesuffix>"
   [(set (match_operand:AVXMODEF2P 0 "nonimmediate_operand" "=x,m")
 	(unspec:AVXMODEF2P
 	  [(match_operand:AVXMODEF2P 1 "nonimmediate_operand" "xm,x")]
@@ -429,18 +418,7 @@
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
 
-(define_expand "<sse>_movu<ssemodesuffix>"
-  [(set (match_operand:SSEMODEF2P 0 "nonimmediate_operand" "")
-	(unspec:SSEMODEF2P
-	  [(match_operand:SSEMODEF2P 1 "nonimmediate_operand" "")]
-	  UNSPEC_MOVU))]
-  "SSE_VEC_FLOAT_MODE_P (<MODE>mode)"
-{
-  if (MEM_P (operands[0]) && MEM_P (operands[1]))
-    operands[1] = force_reg (<MODE>mode, operands[1]);
-})
-
-(define_insn "*<sse>_movu<ssemodesuffix>"
+(define_insn "<sse>_movu<ssemodesuffix>"
   [(set (match_operand:SSEMODEF2P 0 "nonimmediate_operand" "=x,m")
 	(unspec:SSEMODEF2P
 	  [(match_operand:SSEMODEF2P 1 "nonimmediate_operand" "xm,x")]
@@ -452,18 +430,7 @@
    (set_attr "movu" "1")
    (set_attr "mode" "<MODE>")])
 
-(define_expand "avx_movdqu<avxmodesuffix>"
-  [(set (match_operand:AVXMODEQI 0 "nonimmediate_operand" "")
-	(unspec:AVXMODEQI
-	  [(match_operand:AVXMODEQI 1 "nonimmediate_operand" "")]
-	  UNSPEC_MOVU))]
-  "TARGET_AVX"
-{
-  if (MEM_P (operands[0]) && MEM_P (operands[1]))
-    operands[1] = force_reg (<MODE>mode, operands[1]);
-})
-
-(define_insn "*avx_movdqu<avxmodesuffix>"
+(define_insn "avx_movdqu<avxmodesuffix>"
   [(set (match_operand:AVXMODEQI 0 "nonimmediate_operand" "=x,m")
 	(unspec:AVXMODEQI
 	  [(match_operand:AVXMODEQI 1 "nonimmediate_operand" "xm,x")]
@@ -475,17 +442,7 @@
    (set_attr "prefix" "vex")
    (set_attr "mode" "<avxvecmode>")])
 
-(define_expand "sse2_movdqu"
-  [(set (match_operand:V16QI 0 "nonimmediate_operand" "")
-	(unspec:V16QI [(match_operand:V16QI 1 "nonimmediate_operand" "")]
-		      UNSPEC_MOVU))]
-  "TARGET_SSE2"
-{
-  if (MEM_P (operands[0]) && MEM_P (operands[1]))
-    operands[1] = force_reg (V16QImode, operands[1]);
-})
-
-(define_insn "*sse2_movdqu"
+(define_insn "sse2_movdqu"
   [(set (match_operand:V16QI 0 "nonimmediate_operand" "=x,m")
 	(unspec:V16QI [(match_operand:V16QI 1 "nonimmediate_operand" "xm,x")]
 		      UNSPEC_MOVU))]
@@ -1324,15 +1281,15 @@
 		(parallel [(const_int 0)]))
 	      (vec_select:DF (match_dup 1) (parallel [(const_int 1)])))
 	    (plusminus:DF
-	      (vec_select:DF (match_dup 1) (parallel [(const_int 2)]))
-	      (vec_select:DF (match_dup 1) (parallel [(const_int 3)]))))
-	  (vec_concat:V2DF
-	    (plusminus:DF
 	      (vec_select:DF
 		(match_operand:V4DF 2 "nonimmediate_operand" "xm")
 		(parallel [(const_int 0)]))
-	      (vec_select:DF (match_dup 2) (parallel [(const_int 1)])))
+	      (vec_select:DF (match_dup 2) (parallel [(const_int 1)]))))
+	  (vec_concat:V2DF
 	    (plusminus:DF
+	      (vec_select:DF (match_dup 1) (parallel [(const_int 2)]))
+	      (vec_select:DF (match_dup 1) (parallel [(const_int 3)])))
+	    (plusminus:DF
 	      (vec_select:DF (match_dup 2) (parallel [(const_int 2)]))
 	      (vec_select:DF (match_dup 2) (parallel [(const_int 3)]))))))]
   "TARGET_AVX"
@@ -5058,7 +5015,7 @@
 	  (vec_select:DF (match_dup 0) (parallel [(const_int 1)]))))]
   "TARGET_SSE2 && reload_completed"
   [(set (match_dup 0) (match_dup 1))]
-  "operands[0] = adjust_address (operands[0], DFmode, 8);")
+  "operands[0] = adjust_address (operands[0], DFmode, 0);")
 
 ;; Not sure these two are ever used, but it doesn't hurt to have
 ;; them. -aoliva
@@ -12095,7 +12052,7 @@
 	  (unspec:V8SF [(match_operand:V8HI 1 "register_operand" "x")]
 		       UNSPEC_VCVTPH2PS)
 	  (parallel [(const_int 0) (const_int 1)
-		     (const_int 1) (const_int 2)])))]
+		     (const_int 2) (const_int 3)])))]
   "TARGET_F16C"
   "vcvtph2ps\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
Index: gcc/config/i386/linux-unwind.h
===================================================================
--- gcc/config/i386/linux-unwind.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/i386/linux-unwind.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,5 +1,6 @@
 /* DWARF2 EH unwinding support for AMD x86-64 and x86.
-   Copyright (C) 2004, 2005, 2006, 2009, 2010 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2006, 2009, 2010, 2012 Free Software Foundation,
+   Inc.
 
 This file is part of GCC.
 
@@ -133,9 +134,9 @@
     {
       struct rt_sigframe {
 	int sig;
-	struct siginfo *pinfo;
+	siginfo_t *pinfo;
 	void *puc;
-	struct siginfo info;
+	siginfo_t info;
 	struct ucontext uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
Index: gcc/config/i386/i386-protos.h
===================================================================
--- gcc/config/i386/i386-protos.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/i386/i386-protos.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -59,7 +59,8 @@
 extern bool constant_address_p (rtx);
 extern bool legitimate_pic_operand_p (rtx);
 extern bool legitimate_pic_address_disp_p (rtx);
-
+extern bool ix86_legitimize_reload_address (rtx, enum machine_mode,
+					    int, int, int);
 extern void print_reg (rtx, int, FILE*);
 extern void ix86_print_operand (FILE *, rtx, int);
 
Index: gcc/config/i386/driver-i386.c
===================================================================
--- gcc/config/i386/driver-i386.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/i386/driver-i386.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -397,6 +397,7 @@
   unsigned int has_pclmul = 0, has_abm = 0, has_lwp = 0;
   unsigned int has_fma = 0, has_fma4 = 0, has_xop = 0;
   unsigned int has_bmi = 0, has_tbm = 0;
+  unsigned int has_rdrnd = 0, has_f16c = 0, has_fsgsbase = 0;
 
   bool arch;
 
@@ -444,6 +445,8 @@
   has_aes = ecx & bit_AES;
   has_pclmul = ecx & bit_PCLMUL;
   has_fma = ecx & bit_FMA;
+  has_f16c = ecx & bit_F16C;
+  has_rdrnd = ecx & bit_RDRND;
 
   has_cmpxchg8b = edx & bit_CMPXCHG8B;
   has_cmov = edx & bit_CMOV;
@@ -451,6 +454,13 @@
   has_sse = edx & bit_SSE;
   has_sse2 = edx & bit_SSE2;
 
+  if (max_level >= 7)
+    {
+      __cpuid_count (7, 0, eax, ebx, ecx, edx);
+
+      has_fsgsbase = ebx & bit_FSGSBASE;
+    }
+
   /* Check cpuid level of extended features.  */
   __cpuid (0x80000000, ext_level, ebx, ecx, edx);
 
@@ -711,10 +721,13 @@
       const char *avx = has_avx ? " -mavx" : " -mno-avx";
       const char *sse4_2 = has_sse4_2 ? " -msse4.2" : " -mno-sse4.2";
       const char *sse4_1 = has_sse4_1 ? " -msse4.1" : " -mno-sse4.1";
+      const char *rdrnd = has_rdrnd ? " -mrdrnd" : " -mno-rdrnd";
+      const char *f16c = has_f16c ? " -mf16c" : " -mno-f16c";
+      const char *fsgsbase = has_fsgsbase ? " -mfsgsbase" : " -mno-fsgsbase";
 
       options = concat (options, cx16, sahf, movbe, ase, pclmul,
 			popcnt, abm, lwp, fma, fma4, xop, bmi, tbm,
-			avx, sse4_2, sse4_1, NULL);
+			avx, sse4_2, sse4_1, rdrnd, f16c, fsgsbase, NULL);
     }
 
 done:
Index: gcc/config/i386/i386.c
===================================================================
--- gcc/config/i386/i386.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/i386/i386.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -46,6 +46,7 @@
 #include "target.h"
 #include "target-def.h"
 #include "langhooks.h"
+#include "reload.h"
 #include "cgraph.h"
 #include "gimple.h"
 #include "dwarf2.h"
@@ -2094,7 +2095,7 @@
 /* Feature tests against the various architecture variations, used to create
    ix86_arch_features based on the processor mask.  */
 static unsigned int initial_ix86_arch_features[X86_ARCH_LAST] = {
-  /* X86_ARCH_CMOVE: Conditional move was added for pentiumpro.  */
+  /* X86_ARCH_CMOV: Conditional move was added for pentiumpro.  */
   ~(m_386 | m_486 | m_PENT | m_K6),
 
   /* X86_ARCH_CMPXCHG: Compare and exchange was added for 80486.  */
@@ -3811,7 +3812,7 @@
 	   -mtune (rather than -march) points us to a processor that has them.
 	   However, the VIA C3 gives a SIGILL, so we only do that for i686 and
 	   higher processors.  */
-	if (TARGET_CMOVE
+	if (TARGET_CMOV
 	    && (processor_alias_table[i].flags & (PTA_PREFETCH_SSE | PTA_SSE)))
 	  x86_prefetch_sse = true;
 	break;
@@ -4181,12 +4182,6 @@
       target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;
     }
 
-  /* For sane SSE instruction set generation we need fcomi instruction.
-     It is safe to enable all CMOVE instructions.  Also, RDRAND intrinsic
-     expands to a sequence that includes conditional move. */
-  if (TARGET_SSE || TARGET_RDRND)
-    TARGET_CMOVE = 1;
-
   /* Figure out what ASM_GENERATE_INTERNAL_LABEL builds as a prefix.  */
   {
     char *p;
@@ -12168,6 +12163,64 @@
   return false;
 }
 
+/* Our implementation of LEGITIMIZE_RELOAD_ADDRESS.  Returns a value to
+   replace the input X, or the original X if no replacement is called for.
+   The output parameter *WIN is 1 if the calling macro should goto WIN,
+   0 if it should not.  */
+
+bool
+ix86_legitimize_reload_address (rtx x,
+				enum machine_mode mode ATTRIBUTE_UNUSED,
+				int opnum, int type,
+				int ind_levels ATTRIBUTE_UNUSED)
+{
+  /* Reload can generate:
+
+     (plus:DI (plus:DI (unspec:DI [(const_int 0 [0])] UNSPEC_TP)
+		       (reg:DI 97))
+	      (reg:DI 2 cx))
+
+     This RTX is rejected from ix86_legitimate_address_p due to
+     non-strictness of base register 97.  Following this rejection, 
+     reload pushes all three components into separate registers,
+     creating invalid memory address RTX.
+
+     Following code reloads only the invalid part of the
+     memory address RTX.  */
+
+  if (GET_CODE (x) == PLUS
+      && REG_P (XEXP (x, 1))
+      && GET_CODE (XEXP (x, 0)) == PLUS
+      && REG_P (XEXP (XEXP (x, 0), 1)))
+    {
+      rtx base, index;
+      bool something_reloaded = false;
+
+      base = XEXP (XEXP (x, 0), 1);      
+      if (!REG_OK_FOR_BASE_STRICT_P (base))
+	{
+	  push_reload (base, NULL_RTX, &XEXP (XEXP (x, 0), 1), NULL,
+		       BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,
+		       opnum, (enum reload_type)type);
+	  something_reloaded = true;
+	}
+
+      index = XEXP (x, 1);
+      if (!REG_OK_FOR_INDEX_STRICT_P (index))
+	{
+	  push_reload (index, NULL_RTX, &XEXP (x, 1), NULL,
+		       INDEX_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,
+		       opnum, (enum reload_type)type);
+	  something_reloaded = true;
+	}
+
+      gcc_assert (something_reloaded);
+      return true;
+    }
+
+  return false;
+}
+
 /* Recognizes RTL expressions that are valid memory addresses for an
    instruction.  The MODE argument is the machine mode for the MEM
    expression that wants to use this address.
@@ -27177,8 +27230,8 @@
       arg_adjust = 0;
       if (optimize
 	  || target == 0
-	  || GET_MODE (target) != tmode
-	  || !insn_p->operand[0].predicate (target, tmode))
+	  || !register_operand (target, tmode)
+	  || GET_MODE (target) != tmode)
 	target = gen_reg_rtx (tmode);
     }
 
@@ -31377,9 +31430,9 @@
 	  tmp = gen_reg_rtx (GET_MODE_INNER (mode));
 	  ix86_expand_vector_extract (true, tmp, target, 1 - elt);
 	  if (elt == 0)
+	    tmp = gen_rtx_VEC_CONCAT (mode, val, tmp);
+	  else
 	    tmp = gen_rtx_VEC_CONCAT (mode, tmp, val);
-	  else
-	    tmp = gen_rtx_VEC_CONCAT (mode, val, tmp);
 	  emit_insn (gen_rtx_SET (VOIDmode, target, tmp));
 	  return;
 	}
@@ -31393,9 +31446,9 @@
       tmp = gen_reg_rtx (GET_MODE_INNER (mode));
       ix86_expand_vector_extract (false, tmp, target, 1 - elt);
       if (elt == 0)
+	tmp = gen_rtx_VEC_CONCAT (mode, val, tmp);
+      else
 	tmp = gen_rtx_VEC_CONCAT (mode, tmp, val);
-      else
-	tmp = gen_rtx_VEC_CONCAT (mode, val, tmp);
       emit_insn (gen_rtx_SET (VOIDmode, target, tmp));
       return;
 
@@ -32823,7 +32876,8 @@
         return ix86_cost->cond_not_taken_branch_cost;
 
       case vec_perm:
-        return 1;
+      case vec_promote_demote:
+        return ix86_cost->vec_stmt_cost;
 
       default:
         gcc_unreachable ();
Index: gcc/config/sh/linux-unwind.h
===================================================================
--- gcc/config/sh/linux-unwind.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/sh/linux-unwind.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,5 +1,6 @@
 /* DWARF2 EH unwinding support for SH Linux.
-   Copyright (C) 2004, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2006, 2007, 2009, 2012 Free Software Foundation,
+   Inc.
 
 This file is part of GCC.
 
@@ -80,9 +81,9 @@
 	   && (*(unsigned long *) (pc+11)  == 0x6ff0fff0))
     {
       struct rt_sigframe {
-	struct siginfo *pinfo;
+	siginfo_t *pinfo;
 	void *puc;
-	struct siginfo info;
+	siginfo_t info;
 	struct ucontext uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
@@ -179,7 +180,7 @@
 		&& (*(unsigned short *) (pc+14)  == 0x00ad))))
     {
       struct rt_sigframe {
-	struct siginfo info;
+	siginfo_t info;
 	struct ucontext uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
Index: gcc/config/sh/sh.c
===================================================================
--- gcc/config/sh/sh.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/sh/sh.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -763,11 +763,6 @@
   SUBTARGET_OVERRIDE_OPTIONS;
   if (optimize > 1 && !optimize_size)
     target_flags |= MASK_SAVE_ALL_TARGET_REGS;
-  if (flag_finite_math_only == 2)
-    flag_finite_math_only
-      = !flag_signaling_nans && TARGET_SH2E && ! TARGET_IEEE;
-  if (TARGET_SH2E && !flag_finite_math_only)
-    target_flags |= MASK_IEEE;
   sh_cpu = PROCESSOR_SH1;
   assembler_dialect = 0;
   if (TARGET_SH2)
@@ -911,8 +906,6 @@
     if (! VALID_REGISTER_P (ADDREGNAMES_REGNO (regno)))
       sh_additional_register_names[regno][0] = '\0';
 
-  flag_omit_frame_pointer = (PREFERRED_DEBUGGING_TYPE == DWARF2_DEBUG);
-
   if ((flag_pic && ! TARGET_PREFERGOT)
       || (TARGET_SHMEDIA && !TARGET_PT_FIXED))
     flag_no_function_cse = 1;
@@ -944,22 +937,17 @@
 	flag_schedule_insns = 0;
     }
 
-    if ((target_flags_explicit & MASK_ACCUMULATE_OUTGOING_ARGS) == 0)
-       target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;
-
   /* Unwind info is not correct around the CFG unless either a frame 
      pointer is present or M_A_O_A is set.  Fixing this requires rewriting 
      unwind info generation to be aware of the CFG and propagating states 
      around edges.  */
   if ((flag_unwind_tables || flag_asynchronous_unwind_tables
        || flag_exceptions || flag_non_call_exceptions)   
-      && flag_omit_frame_pointer
-      && !(target_flags & MASK_ACCUMULATE_OUTGOING_ARGS))
+      && flag_omit_frame_pointer && !TARGET_ACCUMULATE_OUTGOING_ARGS)
     {
-      if (target_flags_explicit & MASK_ACCUMULATE_OUTGOING_ARGS)
 	warning (0, "unwind tables currently require either a frame pointer "
 		 "or -maccumulate-outgoing-args for correctness");
-      target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;
+	TARGET_ACCUMULATE_OUTGOING_ARGS = 1;
     }
 
   /* Unwinding with -freorder-blocks-and-partition does not work on this
@@ -1014,11 +1002,16 @@
 	align_functions = min_align;
     }
 
+  /* If the -mieee option was not explicitly set by the user, turn it on
+     unless -ffinite-math-only was specified.  See also PR 33135.  */
+  if (! global_options_set.x_TARGET_IEEE)
+    TARGET_IEEE = ! flag_finite_math_only;
+
   if (sh_fixed_range_str)
     sh_fix_range (sh_fixed_range_str);
 
   /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0)
+  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 }
 
Index: gcc/config/sh/sh.opt
===================================================================
--- gcc/config/sh/sh.opt	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/sh/sh.opt	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -202,7 +202,7 @@
 Generate FPU-less SHcompact code
 
 maccumulate-outgoing-args
-Target Report Mask(ACCUMULATE_OUTGOING_ARGS)
+Target Report Var(TARGET_ACCUMULATE_OUTGOING_ARGS) Init(1)
 Reserve space for outgoing arguments in the function prologue
 
 madjust-unroll
@@ -270,8 +270,8 @@
 Follow Renesas (formerly Hitachi) / SuperH calling conventions
 
 mieee
-Target Report Mask(IEEE)
-Increase the IEEE compliance for floating-point code
+Target Var(TARGET_IEEE)
+Increase the IEEE compliance for floating-point comparisons
 
 mindexed-addressing
 Target Report Mask(ALLOW_INDEXED_ADDRESS) Condition(SUPPORT_ANY_SH5_32MEDIA)
Index: gcc/config/avr/avr-stdint.h
===================================================================
--- gcc/config/avr/avr-stdint.h	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ gcc/config/avr/avr-stdint.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,66 @@
+/* Definitions for <stdint.h> types on systems using newlib.
+   Copyright (C) 2012 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/*
+   The intention of this file is to supply definitions that work with
+   avr-gcc's -mint8 that sets int to an 8-bit type.
+
+   This file is intended to yield the same results as newlib-stdint.h,
+   but there are some differences to newlib-stdint.h:
+
+   - AVR is an 8-bit architecture that cannot access 16-bit values
+     atomically, this SIG_ATOMIC_TYPE is "char".
+
+   - For the same reason, [u]int_fast8_t is defined as 8-bit type.
+
+*/
+   
+#define SIG_ATOMIC_TYPE "char"
+
+#define INT8_TYPE "signed char"
+#define INT16_TYPE (INT_TYPE_SIZE == 16 ? "short int" : "long int")
+#define INT32_TYPE (INT_TYPE_SIZE == 16 ? "long int" : "long long int")
+#define INT64_TYPE (INT_TYPE_SIZE == 16 ? "long long int" : 0)
+#define UINT8_TYPE "unsigned char"
+#define UINT16_TYPE (INT_TYPE_SIZE == 16 ? "short unsigned int" : "long unsigned int")
+#define UINT32_TYPE (INT_TYPE_SIZE == 16 ? "long unsigned int" : "long long unsigned int")
+#define UINT64_TYPE (INT_TYPE_SIZE == 16 ? "long long unsigned int" : 0)
+
+#define INT_LEAST8_TYPE INT8_TYPE
+#define INT_LEAST16_TYPE INT16_TYPE
+#define INT_LEAST32_TYPE INT32_TYPE
+#define INT_LEAST64_TYPE INT64_TYPE
+#define UINT_LEAST8_TYPE UINT8_TYPE
+#define UINT_LEAST16_TYPE UINT16_TYPE
+#define UINT_LEAST32_TYPE UINT32_TYPE
+#define UINT_LEAST64_TYPE UINT64_TYPE
+
+#define INT_FAST8_TYPE INT8_TYPE
+#define INT_FAST16_TYPE (INT_TYPE_SIZE == 16 ? "int" : INT16_TYPE)
+#define INT_FAST32_TYPE INT32_TYPE
+#define INT_FAST64_TYPE INT64_TYPE
+#define UINT_FAST8_TYPE UINT8_TYPE
+#define UINT_FAST16_TYPE (INT_TYPE_SIZE == 16 ? "unsigned int" : UINT16_TYPE)
+#define UINT_FAST32_TYPE UINT32_TYPE
+#define UINT_FAST64_TYPE UINT64_TYPE
+
+#define INTPTR_TYPE PTRDIFF_TYPE
+#ifndef UINTPTR_TYPE
+#define UINTPTR_TYPE SIZE_TYPE
+#endif
Index: gcc/config/avr/libgcc.S
===================================================================
--- gcc/config/avr/libgcc.S	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/avr/libgcc.S	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -582,16 +582,7 @@
 	push r17
 	push r28
 	push r29
-#if defined (__AVR_HAVE_8BIT_SP__)
-;; FIXME: __AVR_HAVE_8BIT_SP__ is set on device level, not on core level
-;;        so this lines are dead code.  To make it work, devices without
-;;        SP_H must get their own multilib(s), see PR51345.
 	in	r28,__SP_L__
-	sub	r28,r26
-	clr	r29
-	out	__SP_L__,r28
-#else
-	in	r28,__SP_L__
 	in	r29,__SP_H__
 	sub	r28,r26
 	sbc	r29,r27
@@ -600,7 +591,6 @@
 	out	__SP_H__,r29
 	out	__SREG__,__tmp_reg__
 	out	__SP_L__,r28
-#endif
 #if defined (__AVR_HAVE_EIJMP_EICALL__)
 	eijmp
 #else
@@ -635,15 +625,6 @@
 	ldd	r16,Y+4
 	ldd	r17,Y+3
 	ldd	r26,Y+2
-#if defined (__AVR_HAVE_8BIT_SP__)
-;; FIXME: __AVR_HAVE_8BIT_SP__ is set on device level, not on core level
-;;        so this lines are dead code.  To make it work, devices without
-;;        SP_H must get their own multilib(s).
-	ldd	r29,Y+1
-	add	r28,r30
-	out	__SP_L__,r28
-	mov	r28, r26
-#else
 	ldd	r27,Y+1
 	add	r28,r30
 	adc	r29,__zero_reg__
@@ -654,7 +635,6 @@
 	out	__SP_L__,r28
 	mov_l	r28, r26
 	mov_h	r29, r27
-#endif
 	ret
 .endfunc
 #endif /* defined (L_epilogue) */
Index: gcc/config/avr/avr.md
===================================================================
--- gcc/config/avr/avr.md	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/avr/avr.md	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -299,7 +299,7 @@
   [(set (match_operand:HI 0 "stack_register_operand" "=q")
         (unspec_volatile:HI [(match_operand:HI 1 "register_operand"  "r")] 
 			    UNSPECV_WRITE_SP_IRQ_OFF))]
-  "!AVR_HAVE_8BIT_SP"
+  ""
   "out __SP_H__, %B1
 	out __SP_L__, %A1"
   [(set_attr "length" "2")
@@ -309,7 +309,7 @@
   [(set (match_operand:HI 0 "stack_register_operand" "=q")
         (unspec_volatile:HI [(match_operand:HI 1 "register_operand"  "r")] 
 			    UNSPECV_WRITE_SP_IRQ_ON))]
-  "!AVR_HAVE_8BIT_SP"
+  ""
   "cli
         out __SP_H__, %B1
 	sei
Index: gcc/config/avr/avr.c
===================================================================
--- gcc/config/avr/avr.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/avr/avr.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1879,12 +1879,9 @@
 	    }
 	  else if (test_hard_reg_class (STACK_REG, src))
 	    {
-              *l = 2;
-              return AVR_HAVE_8BIT_SP
-                ? (AS2 (in,%A0,__SP_L__) CR_TAB
-                   AS1 (clr,%B0))
-                : (AS2 (in,%A0,__SP_L__) CR_TAB
-                   AS2 (in,%B0,__SP_H__));
+	      *l = 2;	
+	      return (AS2 (in,%A0,__SP_L__) CR_TAB
+		      AS2 (in,%B0,__SP_H__));
 	    }
 
 	  if (AVR_HAVE_MOVW)
@@ -5177,10 +5174,9 @@
 
   default_file_start ();
 
-  fputs ("__SREG__ = 0x3f\n", asm_out_file);
-  if (!AVR_HAVE_8BIT_SP)
-    fputs ("__SP_H__ = 0x3e\n", asm_out_file);
-  fputs ("__SP_L__ = 0x3d\n", asm_out_file);
+  fputs ("__SREG__ = 0x3f\n"
+	 "__SP_H__ = 0x3e\n"
+	 "__SP_L__ = 0x3d\n", asm_out_file);
   
   fputs ("__tmp_reg__ = 0\n" 
          "__zero_reg__ = 1\n", asm_out_file);
Index: gcc/config/xtensa/linux-unwind.h
===================================================================
--- gcc/config/xtensa/linux-unwind.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/xtensa/linux-unwind.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for Xtensa.
-   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2008, 2009, 2012 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -62,7 +62,7 @@
   struct sigcontext *sc;
 
   struct rt_sigframe {
-    struct siginfo info;
+    siginfo_t info;
     struct ucontext uc;
   } *rt_;
 
Index: gcc/config/host-linux.c
===================================================================
--- gcc/config/host-linux.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/host-linux.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -84,6 +84,8 @@
 # define TRY_EMPTY_VM_SPACE	0x60000000
 #elif defined(__mc68000__)
 # define TRY_EMPTY_VM_SPACE	0x40000000
+#elif defined(__ARM_EABI__)
+# define TRY_EMPTY_VM_SPACE     0x60000000
 #else
 # define TRY_EMPTY_VM_SPACE	0
 #endif
Index: gcc/config/mn10300/mn10300.c
===================================================================
--- gcc/config/mn10300/mn10300.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/mn10300/mn10300.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -2505,12 +2505,15 @@
    may access it using GOTOFF instead of GOT.  */
 
 static void
-mn10300_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)
+mn10300_encode_section_info (tree decl, rtx rtl, int first)
 {
   rtx symbol;
 
+  default_encode_section_info (decl, rtl, first);
+
   if (! MEM_P (rtl))
     return;
+
   symbol = XEXP (rtl, 0);
   if (GET_CODE (symbol) != SYMBOL_REF)
     return;
Index: gcc/config/ia64/linux-unwind.h
===================================================================
--- gcc/config/ia64/linux-unwind.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/ia64/linux-unwind.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for IA64 Linux.
-   Copyright (C) 2004, 2005, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2009, 2012 Free Software Foundation, Inc.
 
    This file is part of GCC.
 
@@ -47,7 +47,7 @@
       struct sigframe {
 	char scratch[16];
 	unsigned long sig_number;
-	struct siginfo *info;
+	siginfo_t *info;
 	struct sigcontext *sc;
       } *frame_ = (struct sigframe *)context->psp;
       struct sigcontext *sc = frame_->sc;
@@ -137,7 +137,7 @@
       struct sigframe {
 	char scratch[16];
 	unsigned long sig_number;
-	struct siginfo *info;
+	siginfo_t *info;
 	struct sigcontext *sc;
       } *frame = (struct sigframe *)context->psp;
       struct sigcontext *sc = frame->sc;
Index: gcc/config/rs6000/vector.md
===================================================================
--- gcc/config/rs6000/vector.md	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/rs6000/vector.md	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -448,6 +448,94 @@
   "VECTOR_UNIT_ALTIVEC_P (<MODE>mode)"
   "")
 
+(define_insn_and_split "*vector_uneq<mode>"
+  [(set (match_operand:VEC_F 0 "vfloat_operand" "")
+	(uneq:VEC_F (match_operand:VEC_F 1 "vfloat_operand" "")
+		    (match_operand:VEC_F 2 "vfloat_operand" "")))]
+  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
+  "#"
+  ""
+  [(set (match_dup 3)
+	(gt:VEC_F (match_dup 1)
+		  (match_dup 2)))
+   (set (match_dup 4)
+	(gt:VEC_F (match_dup 2)
+		  (match_dup 1)))
+   (set (match_dup 0)
+	(not:VEC_F (ior:VEC_F (match_dup 3)
+			      (match_dup 4))))]
+  "
+{
+  operands[3] = gen_reg_rtx (<MODE>mode);
+  operands[4] = gen_reg_rtx (<MODE>mode);
+}")
+
+(define_insn_and_split "*vector_ltgt<mode>"
+  [(set (match_operand:VEC_F 0 "vfloat_operand" "")
+	(ltgt:VEC_F (match_operand:VEC_F 1 "vfloat_operand" "")
+		    (match_operand:VEC_F 2 "vfloat_operand" "")))]
+  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
+  "#"
+  ""
+  [(set (match_dup 3)
+	(gt:VEC_F (match_dup 1)
+		  (match_dup 2)))
+   (set (match_dup 4)
+	(gt:VEC_F (match_dup 2)
+		  (match_dup 1)))
+   (set (match_dup 0)
+	(ior:VEC_F (match_dup 3)
+		   (match_dup 4)))]
+  "
+{
+  operands[3] = gen_reg_rtx (<MODE>mode);
+  operands[4] = gen_reg_rtx (<MODE>mode);
+}")
+
+(define_insn_and_split "*vector_ordered<mode>"
+  [(set (match_operand:VEC_F 0 "vfloat_operand" "")
+	(ordered:VEC_F (match_operand:VEC_F 1 "vfloat_operand" "")
+		       (match_operand:VEC_F 2 "vfloat_operand" "")))]
+  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
+  "#"
+  ""
+  [(set (match_dup 3)
+	(ge:VEC_F (match_dup 1)
+		  (match_dup 2)))
+   (set (match_dup 4)
+	(ge:VEC_F (match_dup 2)
+		  (match_dup 1)))
+   (set (match_dup 0)
+	(ior:VEC_F (match_dup 3)
+		   (match_dup 4)))]
+  "
+{
+  operands[3] = gen_reg_rtx (<MODE>mode);
+  operands[4] = gen_reg_rtx (<MODE>mode);
+}")
+
+(define_insn_and_split "*vector_unordered<mode>"
+  [(set (match_operand:VEC_F 0 "vfloat_operand" "")
+	(unordered:VEC_F (match_operand:VEC_F 1 "vfloat_operand" "")
+			 (match_operand:VEC_F 2 "vfloat_operand" "")))]
+  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
+  "#"
+  ""
+  [(set (match_dup 3)
+	(ge:VEC_F (match_dup 1)
+		  (match_dup 2)))
+   (set (match_dup 4)
+	(ge:VEC_F (match_dup 2)
+		  (match_dup 1)))
+   (set (match_dup 0)
+	(not:VEC_F (ior:VEC_F (match_dup 3)
+			      (match_dup 4))))]
+  "
+{
+  operands[3] = gen_reg_rtx (<MODE>mode);
+  operands[4] = gen_reg_rtx (<MODE>mode);
+}")
+
 ;; Note the arguments for __builtin_altivec_vsel are op2, op1, mask
 ;; which is in the reverse order that we want
 (define_expand "vector_select_<mode>"
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -3695,12 +3695,23 @@
       case vec_to_scalar:
       case scalar_to_vec:
       case cond_branch_not_taken:
-      case vec_perm:
         return 1;
 
       case cond_branch_taken:
         return 3;
 
+      case vec_perm:
+	if (TARGET_VSX)
+	  return 4;
+	else
+	  return 1;
+
+      case vec_promote_demote:
+	if (TARGET_VSX)
+	  return 5;
+	else
+	  return 1;
+
       case unaligned_load:
         if (TARGET_VSX && TARGET_ALLOW_MOVMISALIGN)
           {
@@ -15811,7 +15822,6 @@
 print_operand (FILE *file, rtx x, int code)
 {
   int i;
-  HOST_WIDE_INT val;
   unsigned HOST_WIDE_INT uval;
 
   switch (code)
@@ -16252,34 +16262,17 @@
 
     case 'W':
       /* MB value for a PowerPC64 rldic operand.  */
-      val = (GET_CODE (x) == CONST_INT
-	     ? INTVAL (x) : CONST_DOUBLE_HIGH (x));
+      i = clz_hwi (GET_CODE (x) == CONST_INT
+		   ? INTVAL (x) : CONST_DOUBLE_HIGH (x));
 
-      if (val < 0)
-	i = -1;
-      else
-	for (i = 0; i < HOST_BITS_PER_WIDE_INT; i++)
-	  if ((val <<= 1) < 0)
-	    break;
-
 #if HOST_BITS_PER_WIDE_INT == 32
-      if (GET_CODE (x) == CONST_INT && i >= 0)
+      if (GET_CODE (x) == CONST_INT && i > 0)
 	i += 32;  /* zero-extend high-part was all 0's */
       else if (GET_CODE (x) == CONST_DOUBLE && i == 32)
-	{
-	  val = CONST_DOUBLE_LOW (x);
-
-	  gcc_assert (val);
-	  if (val < 0)
-	    --i;
-	  else
-	    for ( ; i < 64; i++)
-	      if ((val <<= 1) < 0)
-		break;
-	}
+	i = clz_hwi (CONST_DOUBLE_LOW (x)) + 32;
 #endif
 
-      fprintf (file, "%d", i + 1);
+      fprintf (file, "%d", i);
       return;
 
     case 'x':
@@ -17229,6 +17222,10 @@
     case EQ:
     case GT:
     case GTU:
+    case ORDERED:
+    case UNORDERED:
+    case UNEQ:
+    case LTGT:
       mask = gen_reg_rtx (mode);
       emit_insn (gen_rtx_SET (VOIDmode,
 			      mask,
Index: gcc/config/rs6000/vsx.md
===================================================================
--- gcc/config/rs6000/vsx.md	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/rs6000/vsx.md	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1006,9 +1006,9 @@
   "VECTOR_MEM_VSX_P (<MODE>mode)"
 {
   if (INTVAL (operands[3]) == 0)
-    return \"xxpermdi %x0,%x1,%x2,1\";
+    return \"xxpermdi %x0,%x2,%x1,1\";
   else if (INTVAL (operands[3]) == 1)
-    return \"xxpermdi %x0,%x2,%x1,0\";
+    return \"xxpermdi %x0,%x1,%x2,0\";
   else
     gcc_unreachable ();
 }
Index: gcc/config/rs6000/rs6000.h
===================================================================
--- gcc/config/rs6000/rs6000.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/rs6000/rs6000.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -469,10 +469,11 @@
 /* ISA 2.01 allowed FCFID to be done in 32-bit, previously it was 64-bit only.
    Enable 32-bit fcfid's on any of the switches for newer ISA machines or
    XILINX.  */
-#define TARGET_FCFID	(TARGET_POWERPC64 \
-			 || TARGET_POPCNTB	/* ISA 2.02 */ \
-			 || TARGET_CMPB		/* ISA 2.05 */ \
-			 || TARGET_POPCNTD	/* ISA 2.06 */ \
+#define TARGET_FCFID	(TARGET_POWERPC64				\
+			 || TARGET_PPC_GPOPT	/* 970/power4 */	\
+			 || TARGET_POPCNTB	/* ISA 2.02 */		\
+			 || TARGET_CMPB		/* ISA 2.05 */		\
+			 || TARGET_POPCNTD	/* ISA 2.06 */		\
 			 || TARGET_XILINX_FPU)
 
 #define TARGET_FCTIDZ	TARGET_FCFID
Index: gcc/config/rs6000/altivec.md
===================================================================
--- gcc/config/rs6000/altivec.md	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/rs6000/altivec.md	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -2394,8 +2394,8 @@
 
 (define_insn "altivec_stvlx"
   [(parallel
-    [(set (match_operand:V4SI 0 "memory_operand" "=Z")
-	  (match_operand:V4SI 1 "register_operand" "v"))
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
      (unspec [(const_int 0)] UNSPEC_STVLX)])]
   "TARGET_ALTIVEC && rs6000_cpu == PROCESSOR_CELL"
   "stvlx %1,%y0"
@@ -2403,8 +2403,8 @@
 
 (define_insn "altivec_stvlxl"
   [(parallel
-    [(set (match_operand:V4SI 0 "memory_operand" "=Z")
-	  (match_operand:V4SI 1 "register_operand" "v"))
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
      (unspec [(const_int 0)] UNSPEC_STVLXL)])]
   "TARGET_ALTIVEC && rs6000_cpu == PROCESSOR_CELL"
   "stvlxl %1,%y0"
@@ -2412,8 +2412,8 @@
 
 (define_insn "altivec_stvrx"
   [(parallel
-    [(set (match_operand:V4SI 0 "memory_operand" "=Z")
-	  (match_operand:V4SI 1 "register_operand" "v"))
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
      (unspec [(const_int 0)] UNSPEC_STVRX)])]
   "TARGET_ALTIVEC && rs6000_cpu == PROCESSOR_CELL"
   "stvrx %1,%y0"
@@ -2421,8 +2421,8 @@
 
 (define_insn "altivec_stvrxl"
   [(parallel
-    [(set (match_operand:V4SI 0 "memory_operand" "=Z")
-	  (match_operand:V4SI 1 "register_operand" "v"))
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
      (unspec [(const_int 0)] UNSPEC_STVRXL)])]
   "TARGET_ALTIVEC && rs6000_cpu == PROCESSOR_CELL"
   "stvrxl %1,%y0"
Index: gcc/config/rs6000/rs6000.md
===================================================================
--- gcc/config/rs6000/rs6000.md	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/rs6000/rs6000.md	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -2524,8 +2524,19 @@
   if (GET_CODE (addr1) == PLUS)
     {
       emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));
-      addr2 = gen_rtx_PLUS (Pmode, op2, XEXP (addr1, 1));
+      if (TARGET_AVOID_XFORM)
+	{
+	  emit_insn (gen_add3_insn (op2, XEXP (addr1, 1), op2));
+	  addr2 = op2;
+	}
+      else
+	addr2 = gen_rtx_PLUS (Pmode, op2, XEXP (addr1, 1));
     }
+  else if (TARGET_AVOID_XFORM)
+    {
+      emit_insn (gen_add3_insn (op2, addr1, GEN_INT (4)));
+      addr2 = op2;
+    }
   else
     {
       emit_move_insn (op2, GEN_INT (4));
@@ -2574,8 +2585,19 @@
   if (GET_CODE (addr1) == PLUS)
     {
       emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));
-      addr2 = gen_rtx_PLUS (Pmode, op2, XEXP (addr1, 1));
+      if (TARGET_AVOID_XFORM)
+	{
+	  emit_insn (gen_add3_insn (op2, XEXP (addr1, 1), op2));
+	  addr2 = op2;
+	}
+      else
+	addr2 = gen_rtx_PLUS (Pmode, op2, XEXP (addr1, 1));
     }
+  else if (TARGET_AVOID_XFORM)
+    {
+      emit_insn (gen_add3_insn (op2, addr1, GEN_INT (4)));
+      addr2 = op2;
+    }
   else
     {
       emit_move_insn (op2, GEN_INT (4));
@@ -2655,8 +2677,19 @@
   if (GET_CODE (addr1) == PLUS)
     {
       emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));
-      addr2 = gen_rtx_PLUS (SImode, op2, XEXP (addr1, 1));
+      if (TARGET_AVOID_XFORM)
+	{
+	  emit_insn (gen_add3_insn (op2, XEXP (addr1, 1), op2));
+	  addr2 = op2;
+	}
+      else
+	addr2 = gen_rtx_PLUS (SImode, op2, XEXP (addr1, 1));
     }
+  else if (TARGET_AVOID_XFORM)
+    {
+      emit_insn (gen_add3_insn (op2, addr1, GEN_INT (4)));
+      addr2 = op2;
+    }
   else
     {
       emit_move_insn (op2, GEN_INT (4));
@@ -2700,8 +2733,19 @@
   if (GET_CODE (addr1) == PLUS)
     {
       emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));
-      addr2 = gen_rtx_PLUS (SImode, op2, XEXP (addr1, 1));
+      if (TARGET_AVOID_XFORM)
+	{
+	  emit_insn (gen_add3_insn (op2, XEXP (addr1, 1), op2));
+	  addr2 = op2;
+	}
+      else
+	addr2 = gen_rtx_PLUS (SImode, op2, XEXP (addr1, 1));
     }
+  else if (TARGET_AVOID_XFORM)
+    {
+      emit_insn (gen_add3_insn (op2, addr1, GEN_INT (4)));
+      addr2 = op2;
+    }
   else
     {
       emit_move_insn (op2, GEN_INT (4));

Property changes on: gcc/config/rs6000/rs6000.md
___________________________________________________________________
Added: svn:mergeinfo
   Merged /trunk/gcc/config/rs6000/rs6000.md:r187119
Index: gcc/config/arm/arm.c
===================================================================
--- gcc/config/arm/arm.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/arm/arm.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -2005,7 +2005,8 @@
 			   global_options_set.x_param_values);
 
   /* ARM EABI defaults to strict volatile bitfields.  */
-  if (TARGET_AAPCS_BASED && flag_strict_volatile_bitfields < 0)
+  if (TARGET_AAPCS_BASED && flag_strict_volatile_bitfields < 0
+      && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 
   /* Enable sw prefetching at -O3 for CPUS that have prefetch, and we have deemed
@@ -23422,8 +23423,11 @@
 	}
     }
 
+  /* Note: label is before barrier so that in cmp failure case we still get
+     a barrier to stop subsequent loads floating upwards past the ldrex
+     PR target/48126.  */
+  arm_output_asm_insn (emit, 1, operands, "%sLSYB%%=:", LOCAL_LABEL_PREFIX);
   arm_process_output_memory_barrier (emit, NULL);
-  arm_output_asm_insn (emit, 1, operands, "%sLSYB%%=:", LOCAL_LABEL_PREFIX);
 }
 
 static rtx
Index: gcc/config/arm/arm.h
===================================================================
--- gcc/config/arm/arm.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/arm/arm.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -294,7 +294,8 @@
 #define TARGET_HAVE_DMB		(arm_arch7)
 
 /* Nonzero if this chip implements a memory barrier via CP15.  */
-#define TARGET_HAVE_DMB_MCR	(arm_arch6k && ! TARGET_HAVE_DMB)
+#define TARGET_HAVE_DMB_MCR	(arm_arch6 && ! TARGET_HAVE_DMB \
+				 && ! TARGET_THUMB1)
 
 /* Nonzero if this chip implements a memory barrier instruction.  */
 #define TARGET_HAVE_MEMORY_BARRIER (TARGET_HAVE_DMB || TARGET_HAVE_DMB_MCR)
Index: gcc/config/pa/predicates.md
===================================================================
--- gcc/config/pa/predicates.md	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/pa/predicates.md	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -421,9 +421,9 @@
   (ior (match_operand 0 "register_operand")
        (match_operand 0 "cint_ior_operand")))
 
-;; True iff OP is a CONST_INT of the forms 0...0xxxx or
-;; 0...01...1xxxx. Such values can be the left hand side x in (x <<
-;; r), using the zvdepi instruction.
+;; True iff OP is a CONST_INT of the forms 0...0xxxx, 0...01...1xxxx,
+;; or 1...1xxxx. Such values can be the left hand side x in (x << r),
+;; using the zvdepi instruction.
 
 (define_predicate "lhs_lshift_cint_operand"
   (match_code "const_int")
Index: gcc/config/pa/linux-unwind.h
===================================================================
--- gcc/config/pa/linux-unwind.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/pa/linux-unwind.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for PA Linux.
-   Copyright (C) 2004, 2005, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2009, 2012 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -63,7 +63,7 @@
   int i;
   struct sigcontext *sc;
   struct rt_sigframe {
-    struct siginfo info;
+    siginfo_t info;
     struct ucontext uc;
   } *frame;
 
Index: gcc/config/pa/pa.md
===================================================================
--- gcc/config/pa/pa.md	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/pa/pa.md	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -6348,7 +6348,7 @@
   ""
   "*
 {
-  int x = INTVAL (operands[1]);
+  unsigned HOST_WIDE_INT x = UINTVAL (operands[1]);
   operands[2] = GEN_INT (4 + exact_log2 ((x >> 4) + 1));
   operands[1] = GEN_INT ((x & 0xf) - 0x10);
   return \"{zvdepi %1,%2,%0|depwi,z %1,%%sar,%2,%0}\";
@@ -6366,7 +6366,7 @@
   "exact_log2 (INTVAL (operands[1]) + 1) > 0"
   "*
 {
-  int x = INTVAL (operands[1]);
+  HOST_WIDE_INT x = INTVAL (operands[1]);
   operands[2] = GEN_INT (exact_log2 (x + 1));
   return \"{vdepi -1,%2,%0|depwi -1,%%sar,%2,%0}\";
 }"
@@ -6383,7 +6383,7 @@
   "INTVAL (operands[1]) == -2"
   "*
 {
-  int x = INTVAL (operands[1]);
+  HOST_WIDE_INT x = INTVAL (operands[1]);
   operands[2] = GEN_INT (exact_log2 ((~x) + 1));
   return \"{vdepi 0,%2,%0|depwi 0,%%sar,%2,%0}\";
 }"
@@ -6447,7 +6447,7 @@
   "TARGET_64BIT"
   "*
 {
-  int x = INTVAL (operands[1]);
+  unsigned HOST_WIDE_INT x = UINTVAL (operands[1]);
   operands[2] = GEN_INT (4 + exact_log2 ((x >> 4) + 1));
   operands[1] = GEN_INT ((x & 0x1f) - 0x20);
   return \"depdi,z %1,%%sar,%2,%0\";
@@ -6465,7 +6465,7 @@
   "TARGET_64BIT && exact_log2 (INTVAL (operands[1]) + 1) > 0"
   "*
 {
-  int x = INTVAL (operands[1]);
+  HOST_WIDE_INT x = INTVAL (operands[1]);
   operands[2] = GEN_INT (exact_log2 (x + 1));
   return \"depdi -1,%%sar,%2,%0\";
 }"
@@ -6482,7 +6482,7 @@
   "TARGET_64BIT && INTVAL (operands[1]) == -2"
   "*
 {
-  int x = INTVAL (operands[1]);
+  HOST_WIDE_INT x = INTVAL (operands[1]);
   operands[2] = GEN_INT (exact_log2 ((~x) + 1));
   return \"depdi 0,%%sar,%2,%0\";
 }"
@@ -6671,6 +6671,20 @@
 
 ;; Unconditional and other jump instructions.
 
+;; Trivial return used when no epilogue is needed.
+(define_insn "return"
+  [(return)
+   (use (reg:SI 2))]
+  "pa_can_use_return_insn ()"
+  "*
+{
+  if (TARGET_PA_20)
+    return \"bve%* (%%r2)\";
+  return \"bv%* %%r0(%%r2)\";
+}"
+  [(set_attr "type" "branch")
+   (set_attr "length" "4")])
+
 ;; This is used for most returns.
 (define_insn "return_internal"
   [(return)
@@ -6719,11 +6733,8 @@
   rtx x;
 
   /* Try to use the trivial return first.  Else use the full epilogue.  */
-  if (reload_completed
-      && !frame_pointer_needed
-      && !df_regs_ever_live_p (2)
-      && (compute_frame_size (get_frame_size (), 0) ? 0 : 1))
-    x = gen_return_internal ();
+  if (pa_can_use_return_insn ())
+    x = gen_return ();
   else
     {
       hppa_expand_epilogue ();
Index: gcc/config/pa/pa-protos.h
===================================================================
--- gcc/config/pa/pa-protos.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/pa/pa-protos.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -136,6 +136,7 @@
 extern int cint_ok_for_move (HOST_WIDE_INT);
 extern void hppa_expand_prologue (void);
 extern void hppa_expand_epilogue (void);
+extern bool pa_can_use_return_insn (void);
 extern int ior_mask_p (unsigned HOST_WIDE_INT);
 extern void compute_zdepdi_operands (unsigned HOST_WIDE_INT,
 				     unsigned *);
Index: gcc/config/pa/pa.c
===================================================================
--- gcc/config/pa/pa.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/pa/pa.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -185,6 +185,7 @@
 static void pa_conditional_register_usage (void);
 static enum machine_mode pa_c_mode_for_suffix (char);
 static section *pa_function_section (tree, enum node_frequency, bool, bool);
+static unsigned int pa_section_type_flags (tree, const char *, int);
 
 /* The following extra sections are only used for SOM.  */
 static GTY(()) section *som_readonly_data_section;
@@ -400,6 +401,9 @@
 #undef TARGET_ASM_FUNCTION_SECTION
 #define TARGET_ASM_FUNCTION_SECTION pa_function_section
 
+#undef TARGET_SECTION_TYPE_FLAGS
+#define TARGET_SECTION_TYPE_FLAGS pa_section_type_flags
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 /* Parse the -mfixed-range= option string.  */
@@ -4442,6 +4446,24 @@
     }
 }
 
+bool
+pa_can_use_return_insn (void)
+{
+  if (!reload_completed)
+    return false;
+
+  if (frame_pointer_needed)
+    return false;
+
+  if (df_regs_ever_live_p (2))
+    return false;
+
+  if (crtl->profile)
+    return false;
+
+  return compute_frame_size (get_frame_size (), 0) == 0;
+}
+
 rtx
 hppa_pic_save_rtx (void)
 {
@@ -4586,7 +4608,7 @@
   rtx saved_rp;
   rtx ins;
 
-  /* Instruction stream at the normal return address for the export stub:
+  /* The instruction stream at the return address of a PA1.X export stub is:
 
 	0x4bc23fd1 | stub+8:   ldw -18(sr0,sp),rp
 	0x004010a1 | stub+12:  ldsid (sr0,rp),r1
@@ -4594,11 +4616,17 @@
 	0xe0400002 | stub+20:  be,n 0(sr0,rp)
 
      0xe0400002 must be specified as -532676606 so that it won't be
-     rejected as an invalid immediate operand on 64-bit hosts.  */
+     rejected as an invalid immediate operand on 64-bit hosts.
 
-  HOST_WIDE_INT insns[4] = {0x4bc23fd1, 0x004010a1, 0x00011820, -532676606};
-  int i;
+     The instruction stream at the return address of a PA2.0 export stub is:
 
+	0x4bc23fd1 | stub+8:   ldw -18(sr0,sp),rp
+	0xe840d002 | stub+12:  bve,n (rp)
+  */
+
+  HOST_WIDE_INT insns[4];
+  int i, len;
+
   if (count != 0)
     return NULL_RTX;
 
@@ -4620,11 +4648,26 @@
   ins = copy_to_reg (gen_rtx_AND (Pmode, rp, MASK_RETURN_ADDR));
   label = gen_label_rtx ();
 
+  if (TARGET_PA_20)
+    {
+      insns[0] = 0x4bc23fd1;
+      insns[1] = -398405630;
+      len = 2;
+    }
+  else
+    {
+      insns[0] = 0x4bc23fd1;
+      insns[1] = 0x004010a1;
+      insns[2] = 0x00011820;
+      insns[3] = -532676606;
+      len = 4;
+    }
+
   /* Check the instruction stream at the normal return address for the
      export stub.  If it is an export stub, than our return address is
      really in -24[frameaddr].  */
 
-  for (i = 0; i < 3; i++)
+  for (i = 0; i < len; i++)
     {
       rtx op0 = gen_rtx_MEM (SImode, plus_constant (ins, i * 4)); 
       rtx op1 = GEN_INT (insns[i]);
@@ -7501,7 +7544,7 @@
     return 24;
   else
     {
-      if (!TARGET_LONG_CALLS && distance < 240000)
+      if (!TARGET_LONG_CALLS && distance < MAX_PCREL17F_OFFSET)
 	return 8;
 
       if (TARGET_LONG_ABS_CALL && !flag_pic)
@@ -7714,7 +7757,7 @@
   /* pc-relative branch.  */
   if (!TARGET_LONG_CALLS
       && ((TARGET_PA_20 && !sibcall && distance < 7600000)
-	  || distance < 240000))
+	  || distance < MAX_PCREL17F_OFFSET))
     length += 8;
 
   /* 64-bit plabel sequence.  */
@@ -8073,7 +8116,7 @@
   if (TARGET_FAST_INDIRECT_CALLS
       || (!TARGET_PORTABLE_RUNTIME
 	  && ((TARGET_PA_20 && !TARGET_SOM && distance < 7600000)
-	      || distance < 240000)))
+	      || distance < MAX_PCREL17F_OFFSET)))
     return 8;
 
   if (flag_pic)
@@ -10392,4 +10435,23 @@
   return default_function_section (decl, freq, startup, exit);
 }
 
+/* Implement TARGET_SECTION_TYPE_FLAGS.  */
+
+static unsigned int
+pa_section_type_flags (tree decl, const char *name, int reloc)
+{
+  unsigned int flags;
+
+  flags = default_section_type_flags (decl, name, reloc);
+
+  /* Function labels are placed in the constant pool.  This can
+     cause a section conflict if decls are put in ".data.rel.ro"
+     or ".data.rel.ro.local" using the __attribute__ construct.  */
+  if (strcmp (name, ".data.rel.ro") == 0
+      || strcmp (name, ".data.rel.ro.local") == 0)
+    flags |= SECTION_WRITE | SECTION_RELRO;
+
+  return flags;
+}
+
 #include "gt-pa.h"
Index: gcc/config/pa/pa.h
===================================================================
--- gcc/config/pa/pa.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/pa/pa.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1563,3 +1563,12 @@
 #undef TARGET_HAVE_TLS
 #define TARGET_HAVE_TLS true
 #endif
+
+/* The maximum offset in bytes for a PA 1.X pc-relative call to the
+   head of the preceding stub table.  The selected offsets have been
+   chosen so that approximately one call stub is allocated for every
+   86.7 instructions.  A long branch stub is two instructions when
+   not generating PIC code.  For HP-UX and ELF targets, PIC stubs are
+   seven and four instructions, respectively.  */  
+#define MAX_PCREL17F_OFFSET \
+  (flag_pic ? (TARGET_HPUX ? 198164 : 221312) : 240000)
Index: gcc/config/mips/linux-unwind.h
===================================================================
--- gcc/config/mips/linux-unwind.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/mips/linux-unwind.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,5 +1,6 @@
 /* DWARF2 EH unwinding support for MIPS Linux.
-   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2012 Free Software
+   Foundation, Inc.
 
 This file is part of GCC.
 
@@ -75,7 +76,7 @@
       struct rt_sigframe {
 	u_int32_t ass[4];  /* Argument save space for o32.  */
 	u_int32_t trampoline[2];
-	struct siginfo info;
+	siginfo_t info;
 	_sig_ucontext_t uc;
       } *rt_ = context->cfa;
       sc = &rt_->uc.uc_mcontext;
Index: gcc/config/h8300/h8300.c
===================================================================
--- gcc/config/h8300/h8300.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/h8300/h8300.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -416,7 +416,7 @@
     }
 
   /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0)
+  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 }
 
Index: gcc/config/bfin/linux-unwind.h
===================================================================
--- gcc/config/bfin/linux-unwind.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/config/bfin/linux-unwind.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for Blackfin.
-   Copyright (C) 2007, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2007, 2009, 2012 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -48,10 +48,10 @@
     {
       struct rt_sigframe {
 	int sig;
-	struct siginfo *pinfo;
+	siginfo_t *pinfo;
 	void *puc;
 	char retcode[8];
-	struct siginfo info;
+	siginfo_t info;
 	struct ucontext uc;
       } *rt_ = context->cfa;
 
Index: gcc/convert.c
===================================================================
--- gcc/convert.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ gcc/convert.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -44,11 +44,6 @@
   if (TREE_TYPE (expr) == type)
     return expr;
 
-  /* Propagate overflow to the NULL pointer.  */
-  if (integer_zerop (expr))
-    return force_fit_type_double (type, double_int_zero, 0,
-				  TREE_OVERFLOW (expr));
-
   switch (TREE_CODE (TREE_TYPE (expr)))
     {
     case POINTER_TYPE:
Index: libstdc++-v3/configure
===================================================================
--- libstdc++-v3/configure	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/configure	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -19477,7 +19477,85 @@
 
 
 
+# For copy-assignable gthreads types
 
+
+
+  ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+  ac_save_CXXFLAGS="$CXXFLAGS"
+  CXXFLAGS="$CXXFLAGS -std=c++0x -I${toplevel_srcdir}/gcc"
+
+  target_thread_file=`$CXX -v 2>&1 | sed -n 's/^Thread model: //p'`
+  case $target_thread_file in
+    posix)
+      CXXFLAGS="$CXXFLAGS -DSUPPORTS_WEAK -DGTHREAD_USE_WEAK -D_PTHREADS"
+  esac
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether gthreads types are copy-assignable in C++11 mode" >&5
+$as_echo_n "checking whether gthreads types are copy-assignable in C++11 mode... " >&6; }
+
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include "gthr.h"
+int
+main ()
+{
+
+      #ifdef __GTHREAD_MUTEX_INIT
+      __gthread_mutex_t m1;
+      __gthread_mutex_t m2 = __GTHREAD_MUTEX_INIT;
+      m1 = m2;
+      #endif
+      #ifdef __GTHREAD_RECURSIVE_MUTEX_INIT
+      __gthread_recursive_mutex_t r1;
+      __gthread_recursive_mutex_t r2 = __GTHREAD_RECURSIVE_MUTEX_INIT;
+      r1 = r2;
+      #endif
+      #ifdef __GTHREAD_HAS_COND
+      #ifdef __GTHREAD_COND_INIT
+      __gthread_cond_t c1;
+      __gthread_cond_t c2 = __GTHREAD_COND_INIT;
+      c1 = c2;
+      #endif
+      #endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  ac_gthread_cxx11_copy_assign=1
+else
+  ac_gthread_cxx11_copy_assign=0
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+  if test $ac_gthread_cxx11_copy_assign = 1 ; then res_gthr_copy_assign=yes ;
+  else res_gthr_copy_assign=no ; fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $res_gthr_copy_assign" >&5
+$as_echo "$res_gthr_copy_assign" >&6; }
+
+  if test x"$res_gthr_copy_assign" = x"no"; then
+
+$as_echo "#define _GLIBCXX_GTHREADS_NO_COPY_ASSIGN_IN_CXX11 1" >>confdefs.h
+
+  fi
+
+  CXXFLAGS="$ac_save_CXXFLAGS"
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
   ac_fn_c_check_header_mongrel "$LINENO" "locale.h" "ac_cv_header_locale_h" "$ac_includes_default"
 if test "x$ac_cv_header_locale_h" = x""yes; then :
 
Index: libstdc++-v3/src/condition_variable.cc
===================================================================
--- libstdc++-v3/src/condition_variable.cc	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/src/condition_variable.cc	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,6 +1,6 @@
 // condition_variable -*- C++ -*-
 
-// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+// Copyright (C) 2008, 2009, 2010, 2012 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -34,7 +34,12 @@
   {
 #ifdef __GTHREAD_COND_INIT
     __native_type __tmp = __GTHREAD_COND_INIT;
+#if defined __GXX_EXPERIMENTAL_CXX0X__ \
+  && defined _GLIBCXX_GTHREADS_NO_COPY_ASSIGN_IN_CXX11
+    __builtin_memcpy(&_M_cond, &__tmp, sizeof(_M_cond));
+#else
     _M_cond = __tmp;
+#endif
 #else
     int __e = __gthread_cond_init(&_M_cond, 0);
 
Index: libstdc++-v3/configure.ac
===================================================================
--- libstdc++-v3/configure.ac	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/configure.ac	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -164,6 +164,9 @@
 # For gthread support
 GLIBCXX_CHECK_GTHREADS
 
+# For copy-assignable gthreads types
+GLIBCXX_GTHREADS_CXX11_COPY_ASSIGN
+
 AC_LC_MESSAGES
 
 # Check for available headers.
Index: libstdc++-v3/include/debug/safe_iterator.h
===================================================================
--- libstdc++-v3/include/debug/safe_iterator.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/include/debug/safe_iterator.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,6 +1,6 @@
 // Safe iterator implementation  -*- C++ -*-
 
-// Copyright (C) 2003, 2004, 2005, 2006, 2009, 2010, 2011
+// Copyright (C) 2003, 2004, 2005, 2006, 2009, 2010, 2011, 2012
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -142,7 +142,25 @@
 			      ._M_iterator(__x, "other"));
       }
 
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
       /**
+       * @brief Move construction.
+       * @post __x is singular and unattached
+       */
+      _Safe_iterator(_Safe_iterator&& __x) : _M_current()
+      {
+	_GLIBCXX_DEBUG_VERIFY(!__x._M_singular()
+			      || __x._M_current == _Iterator(),
+			      _M_message(__msg_init_copy_singular)
+			      ._M_iterator(*this, "this")
+			      ._M_iterator(__x, "other"));
+	std::swap(_M_current, __x._M_current);
+	this->_M_attach(__x._M_sequence);
+	__x._M_detach();
+      }
+#endif
+
+      /**
        *  @brief Converting constructor from a mutable iterator to a
        *  constant iterator.
       */
@@ -181,7 +199,28 @@
 	return *this;
       }
 
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
       /**
+       * @brief Move assignment.
+       * @post __x is singular and unattached
+       */
+      _Safe_iterator&
+      operator=(_Safe_iterator&& __x)
+      {
+	_GLIBCXX_DEBUG_VERIFY(!__x._M_singular()
+			      || __x._M_current == _Iterator(),
+			      _M_message(__msg_copy_singular)
+			      ._M_iterator(*this, "this")
+			      ._M_iterator(__x, "other"));
+	_M_current = __x._M_current;
+	_M_attach(__x._M_sequence);
+	__x._M_detach();
+	__x._M_current = _Iterator();
+	return *this;
+      }
+#endif
+
+      /**
        *  @brief Iterator dereference.
        *  @pre iterator is dereferenceable
        */
@@ -415,7 +454,9 @@
       /// Is this iterator equal to the sequence's before_begin() iterator if
       /// any?
       bool _M_is_before_begin() const
-      { return _BeforeBeginHelper<_Sequence>::_M_Is(base(), _M_get_sequence()); }
+      {
+	return _BeforeBeginHelper<_Sequence>::_M_Is(base(), _M_get_sequence());
+      }
     };
 
   template<typename _IteratorL, typename _IteratorR, typename _Sequence>
Index: libstdc++-v3/include/std/condition_variable
===================================================================
--- libstdc++-v3/include/std/condition_variable	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/include/std/condition_variable	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,6 +1,6 @@
 // <condition_variable> -*- C++ -*-
 
-// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+// Copyright (C) 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -171,6 +171,26 @@
     condition_variable			_M_cond;
     mutex				_M_mutex;
 
+    // scoped unlock - unlocks in ctor, re-locks in dtor
+    template<typename _Lock>
+      struct _Unlock
+      {
+	explicit _Unlock(_Lock& __lk) : _M_lock(__lk) { __lk.unlock(); }
+
+	~_Unlock() noexcept(false)
+	{
+	  if (uncaught_exception())
+	    __try { _M_lock.lock(); } __catch(...) { }
+	  else
+	    _M_lock.lock();
+	}
+
+	_Unlock(const _Unlock&) = delete;
+	_Unlock& operator=(const _Unlock&) = delete;
+
+	_Lock& _M_lock;
+      };
+
   public:
     typedef condition_variable::native_handle_type	native_handle_type;
 
@@ -198,21 +218,8 @@
       void
       wait(_Lock& __lock)
       {
-	// scoped unlock - unlocks in ctor, re-locks in dtor
-	struct _Unlock {
-	  explicit _Unlock(_Lock& __lk) : _M_lock(__lk) { __lk.unlock(); }
-	  ~_Unlock() noexcept(false)
-	  {
-	    if (uncaught_exception())
-	      __try { _M_lock.lock(); } __catch(...) { }
-	    else
-	      _M_lock.lock();
-	  }
-	  _Lock& _M_lock;
-	};
-
 	unique_lock<mutex> __my_lock(_M_mutex);
-	_Unlock __unlock(__lock);
+	_Unlock<_Lock> __unlock(__lock);
 	// _M_mutex must be unlocked before re-locking __lock so move
 	// ownership of _M_mutex lock to an object with shorter lifetime.
 	unique_lock<mutex> __my_lock2(std::move(__my_lock));
@@ -233,11 +240,12 @@
       wait_until(_Lock& __lock,
 		 const chrono::time_point<_Clock, _Duration>& __atime)
       {
-        unique_lock<mutex> __my_lock(_M_mutex);
-        __lock.unlock();
-        cv_status __status = _M_cond.wait_until(__my_lock, __atime);
-        __lock.lock();
-        return __status;
+	unique_lock<mutex> __my_lock(_M_mutex);
+	_Unlock<_Lock> __unlock(__lock);
+	// _M_mutex must be unlocked before re-locking __lock so move
+	// ownership of _M_mutex lock to an object with shorter lifetime.
+	unique_lock<mutex> __my_lock2(std::move(__my_lock));
+	return _M_cond.wait_until(__my_lock2, __atime);
       }
 
     template<typename _Lock, typename _Clock,
Index: libstdc++-v3/include/std/mutex
===================================================================
--- libstdc++-v3/include/std/mutex	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/include/std/mutex	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -130,7 +130,7 @@
   public:
     // matches a gthr-win32.h recursive mutex
     template<typename _Rm>
-      static typename enable_if<sizeof(&_Rm::sema), void>::type
+      static typename enable_if<(bool)sizeof(&_Rm::sema), void>::type
       _S_destroy(_Rm* __mx)
       {
         __gthread_mutex_t __tmp;
@@ -139,7 +139,7 @@
 
     // matches a recursive mutex with a member 'actual'
     template<typename _Rm>
-      static typename enable_if<sizeof(&_Rm::actual), void>::type
+      static typename enable_if<(bool)sizeof(&_Rm::actual), void>::type
       _S_destroy(_Rm* __mx)
       { __gthread_mutex_destroy(&__mx->actual); }
 
Index: libstdc++-v3/include/ext/concurrence.h
===================================================================
--- libstdc++-v3/include/ext/concurrence.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/include/ext/concurrence.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,6 +1,6 @@
 // Support for concurrent programing -*- C++ -*-
 
-// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -140,6 +140,18 @@
   }
 #endif
  
+  template<typename _Tp>
+    static inline void
+    __copy_gthr_type(_Tp& __to, const _Tp& __from)
+    {
+#if defined __GXX_EXPERIMENTAL_CXX0X__ \
+  && defined _GLIBCXX_GTHREADS_NO_COPY_ASSIGN_IN_CXX11
+      __builtin_memcpy(&__to, &__from, sizeof(__to));
+#else
+      __to = __from;
+#endif
+    }
+
   class __mutex 
   {
   private:
@@ -156,7 +168,7 @@
 	{
 #if defined __GTHREAD_MUTEX_INIT
 	  __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;
-	  _M_mutex = __tmp;
+	  __copy_gthr_type(_M_mutex, __tmp);
 #else
 	  __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex); 
 #endif
@@ -214,7 +226,7 @@
 	{
 #if defined __GTHREAD_RECURSIVE_MUTEX_INIT
 	  __gthread_recursive_mutex_t __tmp = __GTHREAD_RECURSIVE_MUTEX_INIT;
-	  _M_mutex = __tmp;
+	  __copy_gthr_type(_M_mutex, __tmp);
 #else
 	  __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(&_M_mutex); 
 #endif
@@ -270,7 +282,7 @@
 
     // matches a gthr-win32.h recursive mutex
     template<typename _Rm>
-      static typename __enable_if<sizeof(&_Rm::sema), void>::__type
+      static typename __enable_if<(bool)sizeof(&_Rm::sema), void>::__type
       _S_destroy(_Rm* __mx)
       {
         __gthread_mutex_t __tmp;
@@ -279,7 +291,7 @@
 
     // matches a recursive mutex with a member 'actual'
     template<typename _Rm>
-      static typename __enable_if<sizeof(&_Rm::actual), void>::__type
+      static typename __enable_if<(bool)sizeof(&_Rm::actual), void>::__type
       _S_destroy(_Rm* __mx)
       { __gthread_mutex_destroy(&__mx->actual); }
 
@@ -332,7 +344,7 @@
 	{
 #if defined __GTHREAD_COND_INIT
 	  __gthread_cond_t __tmp = __GTHREAD_COND_INIT;
-	  _M_cond = __tmp;
+	  __copy_gthr_type(_M_cond, __tmp);
 #else
 	  __GTHREAD_COND_INIT_FUNCTION(&_M_cond);
 #endif
Index: libstdc++-v3/include/ext/rope
===================================================================
--- libstdc++-v3/include/ext/rope	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/include/ext/rope	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,7 +1,7 @@
 // SGI's rope class -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
-// Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+// 2012 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -445,6 +445,17 @@
     identity_element(_Rope_Concat_fn<_CharT, _Alloc>)
     { return rope<_CharT, _Alloc>(); }
 
+  static inline void
+  __copy_gthr_mutex(__gthread_mutex_t& __to, const __gthread_mutex_t& __from)
+  {
+#if defined __GXX_EXPERIMENTAL_CXX0X__ \
+  && defined _GLIBCXX_GTHREADS_NO_COPY_ASSIGN_IN_CXX11
+    __builtin_memcpy(&__to, &__from, sizeof(__to));
+#else
+    __to = __from;
+#endif
+  }
+
   // Class _Refcount_Base provides a type, _RC_t, a data member,
   // _M_ref_count, and member functions _M_incr and _M_decr, which perform
   // atomic preincrement/predecrement.  The constructor initializes
@@ -464,7 +475,7 @@
     {
 #ifdef __GTHREAD_MUTEX_INIT
       __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;
-      _M_ref_count_lock = __tmp;
+      __copy_gthr_mutex(_M_ref_count_lock, __tmp);
 #elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)
       __GTHREAD_MUTEX_INIT_FUNCTION (&_M_ref_count_lock);
 #else
@@ -605,7 +616,7 @@
     {
       // Do not copy a POSIX/gthr mutex once in use.  However, bits are bits.
       __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;
-      _M_c_string_lock = __tmp;
+      __copy_gthr_mutex(_M_c_string_lock, __tmp);
     }
 #else
     { __GTHREAD_MUTEX_INIT_FUNCTION (&_M_c_string_lock); }
Index: libstdc++-v3/include/bits/stl_algo.h
===================================================================
--- libstdc++-v3/include/bits/stl_algo.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/include/bits/stl_algo.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1811,7 +1811,8 @@
 	  for (; __first != __last; ++__first)
 	    if (__pred(*__first))
 	      {
-		*__result1 = _GLIBCXX_MOVE(*__first);
+		if (__result1 != __first)
+		  *__result1 = _GLIBCXX_MOVE(*__first);
 		++__result1;
 	      }
 	    else
Index: libstdc++-v3/ChangeLog
===================================================================
--- libstdc++-v3/ChangeLog	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/ChangeLog	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,3 +1,65 @@
+2012-07-22  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	PR libstdc++/53270
+	* acinclude.m4 (GLIBCXX_GTHREADS_CXX11_COPY_ASSIGN): Define.
+	* configure.ac (GLIBCXX_GTHREADS_CXX11_COPY_ASSIGN): Use it.
+	* config.h.in: Regenerate.
+	* configure: Likewise.
+	* include/ext/concurrence.h (__copy_gthr_type): Define.
+	(__mutex::__mutex, __recursive_mutex::__recursive_mutex,
+	__cond::__cond): Use it.
+	* include/ext/rope (__copy_gthr_mutex): Define.
+	(_Refcount_Base::_Refcount_Base, _Rope_RopeRep::_Rope_RopeRep): Use
+	it.
+	* src/condition_variable.cc (condition_variable::condition_variable):
+	Use memcpy instead of assignment.
+
+2012-07-07  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	PR libstdc++/53578
+	* include/ext/concurrence.h (__recursive_mutex::_S_destroy): Fix
+	narrowing conversion.
+	* include/std/mutex (__recursive_mutex_base::_S_destroy): Likewise.
+
+2012-07-05  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	PR libstdc++/53830
+	* include/std/condition_variable (condition_variable_any::wait):
+	Move _Unlock type to class scope.
+	(condition_variable_any::wait_until): Reuse it.
+	* testsuite/30_threads/condition_variable_any/53830.cc: New.
+
+2012-06-20  Jörg Sonnenberger <joerg@britannica.bec.de>
+	    Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	PR libstdc++/53678
+	* config/os/bsd/netbsd/ctype_base.h: Check for _CTYPE_U.
+	* testsuite/22_locale/ctype_base/53678.cc: New.
+
+2012-04-12   Jeffrey Yasskin  <jyasskin@google.com>
+
+	PR libstdc++/52822
+	* include/bits/stl_algo.h (__stable_partition_adaptive): Avoid
+	move-assigning an object to itself by explicitly testing for
+	identity.
+	* testsuite/25_algorithms/stable_partition/pr52822.cc: Test
+	vectors, which have a destructive self-move-assignment.
+	* testsuite/25_algorithms/stable_partition/moveable.cc (test02):
+	Test with rvalstruct, which explicitly checks
+	self-move-assignment.
+
+2012-04-09  Terry Guo  <terry.guo@arm.com>
+
+	* testsuite/Makefile.am (TEST_GCC_EXEC_PREFIX): New.
+	* testsuite/Makefile.in: Regenerated.
+
+2012-03-08  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	PR libstdc++/52433
+	* include/debug/safe_iterator.h (_Safe_iterator): Add move
+	constructor and move assignment operator.
+	* testsuite/23_containers/vector/debug/52433.cc: New.
+
 2012-03-01  Release Manager
 
 	* GCC 4.6.3 released.
Index: libstdc++-v3/testsuite/25_algorithms/stable_partition/pr52822.cc
===================================================================
--- libstdc++-v3/testsuite/25_algorithms/stable_partition/pr52822.cc	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ libstdc++-v3/testsuite/25_algorithms/stable_partition/pr52822.cc	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++0x" }
+
+// Copyright (C) 2012 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 25.2.12 [lib.alg.partitions] Partitions.
+
+#include <algorithm>
+#include <vector>
+#include <testsuite_hooks.h>
+
+bool true_vector_pred(const std::vector<int>&) { return true; }
+
+void
+test01()
+{
+  std::vector<std::vector<int> > v(1);
+  v[0].push_back(7);
+  VERIFY( v[0].size() == 1 );
+  std::stable_partition(v.begin(), v.end(), &true_vector_pred);
+  VERIFY( v[0].size() == 1 );
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/25_algorithms/stable_partition/moveable.cc
===================================================================
--- libstdc++-v3/testsuite/25_algorithms/stable_partition/moveable.cc	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/testsuite/25_algorithms/stable_partition/moveable.cc	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,6 +1,6 @@
 // { dg-options "-std=gnu++0x" }
 
-// Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+// Copyright (C) 2009, 2010, 2012 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -39,6 +39,11 @@
 const int B[] = {2, 4, 6, 8, 10, 12, 14, 16, 1, 3, 5, 7, 9, 11, 13, 15, 17};
 const int N = sizeof(A) / sizeof(int);
 
+// Check that starting with a true predicate works too. (PR52822)
+const int A2[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};
+const int B2[] = {2, 4, 6, 8, 10, 12, 14, 16, 3, 5, 7, 9, 11, 13, 15, 17};
+const int N2 = sizeof(A2) / sizeof(int);
+
 struct Pred
 {
   bool
@@ -46,7 +51,7 @@
   { return (x.val % 2) == 0; }
 };
 
-// 25.2.12 stable_partition()
+// 25.2.12 stable_partition(), starting with a false predicate.
 void
 test01()
 {
@@ -60,9 +65,24 @@
   VERIFY( std::equal(s1, s1 + N, B) );
 }
 
+// 25.2.12 stable_partition(), starting with a true predicate.
+void
+test02()
+{
+  bool test __attribute__((unused)) = true;
+
+  rvalstruct s1[N2];
+  std::copy(A2, A2 + N2, s1);
+  Container con(s1, s1 + N2);
+
+  std::stable_partition(con.begin(), con.end(), Pred());
+  VERIFY( std::equal(s1, s1 + N2, B2) );
+}
+
 int
 main()
 {
   test01();
+  test02();
   return 0;
 }
Index: libstdc++-v3/testsuite/Makefile.in
===================================================================
--- libstdc++-v3/testsuite/Makefile.in	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/testsuite/Makefile.in	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -502,6 +502,7 @@
 	@echo 'set target_triplet $(target_triplet)' >>site.tmp
 	@echo 'set libiconv "$(LIBICONV)"' >>site.tmp
 	@echo 'set baseline_dir "$(baseline_dir)"' >> site.tmp
+	@echo 'set TEST_GCC_EXEC_PREFIX "$(libdir)/gcc/"' >> site.tmp
 	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
 	@test ! -f site.exp || \
 	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
Index: libstdc++-v3/testsuite/30_threads/condition_variable_any/53830.cc
===================================================================
--- libstdc++-v3/testsuite/30_threads/condition_variable_any/53830.cc	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ libstdc++-v3/testsuite/30_threads/condition_variable_any/53830.cc	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,68 @@
+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }
+// { dg-options " -std=gnu++0x -pthread" { target *-*-freebsd* *-*-netbsd* *-*-linux* powerpc-ibm-aix* } }
+// { dg-options " -std=gnu++0x -pthreads" { target *-*-solaris* } }
+// { dg-options " -std=gnu++0x " { target *-*-cygwin *-*-darwin* } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+// { dg-require-sched-yield "" }
+// { dg-require-nanosleep "" }
+
+// Copyright (C) 2012 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// PR libstdc++/53830
+// Test for deadlock in condition_variable_any::wait_for
+
+#include <thread>
+#include <mutex>
+#include <condition_variable>
+#include <chrono>
+#include <atomic>
+
+std::mutex mutex;
+std::condition_variable_any cv;
+
+std::atomic<int> barrier(0);
+
+// waits for data from another thread
+void wait_for_data()
+{
+  std::unique_lock<std::mutex> lock(mutex);
+  barrier = 1;
+  cv.wait_for(lock, std::chrono::milliseconds(100), []{ return false; });
+  // read data
+}
+
+// passes data to waiting thread
+void provide_data()
+{
+  while (barrier == 0)
+    std::this_thread::yield();
+  std::unique_lock<std::mutex> lock(mutex);
+  // pass data
+  std::this_thread::sleep_for(std::chrono::seconds(1));
+  cv.notify_one();
+}
+
+int main()
+{
+  std::thread thread1(wait_for_data);
+  provide_data();
+  thread1.join();
+  return 0;
+}
+
Index: libstdc++-v3/testsuite/22_locale/ctype_base/53678.cc
===================================================================
--- libstdc++-v3/testsuite/22_locale/ctype_base/53678.cc	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ libstdc++-v3/testsuite/22_locale/ctype_base/53678.cc	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,28 @@
+// Copyright (C) 2012 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile }
+
+// 22.2.1 The ctype category
+
+#include <locale>
+
+// libstdc++/53678
+void test01()
+{
+  bool NetBSD __attribute__((unused)) = true;
+}
Index: libstdc++-v3/testsuite/Makefile.am
===================================================================
--- libstdc++-v3/testsuite/Makefile.am	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/testsuite/Makefile.am	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -59,6 +59,7 @@
 	@echo 'set target_triplet $(target_triplet)' >>site.tmp
 	@echo 'set libiconv "$(LIBICONV)"' >>site.tmp
 	@echo 'set baseline_dir "$(baseline_dir)"' >> site.tmp
+	@echo 'set TEST_GCC_EXEC_PREFIX "$(libdir)/gcc/"' >> site.tmp
 	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
 	@test ! -f site.exp || \
 	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
Index: libstdc++-v3/testsuite/23_containers/vector/debug/52433.cc
===================================================================
--- libstdc++-v3/testsuite/23_containers/vector/debug/52433.cc	(.../tags/gcc_4_6_3_release)	(revision 0)
+++ libstdc++-v3/testsuite/23_containers/vector/debug/52433.cc	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -0,0 +1,43 @@
+// Copyright (C) 2012 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+// { dg-require-debug-mode "" }
+// { dg-options "-std=gnu++0x" }
+// { dg-do compile }
+
+// PR libstdc++/52433
+
+#include <vector>
+
+struct X
+{
+    std::vector<int>::iterator i;
+
+    X() = default;
+    X(const X&) = default;
+    X(X&&) = default;
+    X& operator=(const X&) = default;
+    X& operator=(X&&) = default;
+};
+
+X test01()
+{
+    X x;
+    x = X();
+    return x;
+}
+
Index: libstdc++-v3/config.h.in
===================================================================
--- libstdc++-v3/config.h.in	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/config.h.in	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -692,6 +692,9 @@
 /* Define if a fully dynamic basic_string is wanted. */
 #undef _GLIBCXX_FULLY_DYNAMIC_STRING
 
+/* Define if gthreads types cannot be copy-assigned in C++11. */
+#undef _GLIBCXX_GTHREADS_NO_COPY_ASSIGN_IN_CXX11
+
 /* Define if gthreads library is available. */
 #undef _GLIBCXX_HAS_GTHREADS
 
Index: libstdc++-v3/config/os/bsd/netbsd/ctype_base.h
===================================================================
--- libstdc++-v3/config/os/bsd/netbsd/ctype_base.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/config/os/bsd/netbsd/ctype_base.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,6 +1,6 @@
 // Locale support -*- C++ -*-
 
-// Copyright (C) 2000, 2009 Free Software Foundation, Inc.
+// Copyright (C) 2000, 2009, 2011, 2012 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -31,8 +31,6 @@
 //   anoncvs@anoncvs.netbsd.org:/cvsroot/basesrc/include/ctype.h
 // See www.netbsd.org for details of access.
   
-#include <sys/param.h>
-
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -47,7 +45,7 @@
     // on the mask type. Because of this, we don't use an enum.
     typedef unsigned char      	mask;
 
-#if __NetBSD_Version__ < 599004100
+#ifndef _CTYPE_U
     static const mask upper    	= _U;
     static const mask lower 	= _L;
     static const mask alpha 	= _U | _L;
Index: libstdc++-v3/acinclude.m4
===================================================================
--- libstdc++-v3/acinclude.m4	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libstdc++-v3/acinclude.m4	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -3213,6 +3213,58 @@
   ])
 ])
 
+dnl
+dnl Check whether gthreads types can be copy-assigned in C++11 mode.
+dnl
+AC_DEFUN([GLIBCXX_GTHREADS_CXX11_COPY_ASSIGN], [
+
+  AC_LANG_SAVE
+  AC_LANG_CPLUSPLUS
+  ac_save_CXXFLAGS="$CXXFLAGS"
+  CXXFLAGS="$CXXFLAGS -std=c++0x -I${toplevel_srcdir}/gcc"
+
+  target_thread_file=`$CXX -v 2>&1 | sed -n 's/^Thread model: //p'`
+  case $target_thread_file in
+    posix)
+      CXXFLAGS="$CXXFLAGS -DSUPPORTS_WEAK -DGTHREAD_USE_WEAK -D_PTHREADS"
+  esac
+
+  AC_MSG_CHECKING([whether gthreads types are copy-assignable in C++11 mode])
+
+  AC_TRY_COMPILE([#include "gthr.h"],
+    [
+      #ifdef __GTHREAD_MUTEX_INIT
+      __gthread_mutex_t m1;
+      __gthread_mutex_t m2 = __GTHREAD_MUTEX_INIT;
+      m1 = m2;
+      #endif
+      #ifdef __GTHREAD_RECURSIVE_MUTEX_INIT
+      __gthread_recursive_mutex_t r1;
+      __gthread_recursive_mutex_t r2 = __GTHREAD_RECURSIVE_MUTEX_INIT;
+      r1 = r2;
+      #endif
+      #ifdef __GTHREAD_HAS_COND
+      #ifdef __GTHREAD_COND_INIT
+      __gthread_cond_t c1;
+      __gthread_cond_t c2 = __GTHREAD_COND_INIT;
+      c1 = c2;
+      #endif
+      #endif
+    ], [ac_gthread_cxx11_copy_assign=1], [ac_gthread_cxx11_copy_assign=0])
+
+  if test $ac_gthread_cxx11_copy_assign = 1 ; then res_gthr_copy_assign=yes ;
+  else res_gthr_copy_assign=no ; fi
+  AC_MSG_RESULT([$res_gthr_copy_assign])
+
+  if test x"$res_gthr_copy_assign" = x"no"; then
+    AC_DEFINE(_GLIBCXX_GTHREADS_NO_COPY_ASSIGN_IN_CXX11, 1,
+	      [Define if gthreads types cannot be copy-assigned in C++11.])
+  fi
+
+  CXXFLAGS="$ac_save_CXXFLAGS"
+  AC_LANG_RESTORE
+])
+
 # Macros from the top-level gcc directory.
 m4_include([../config/gc++filt.m4])
 m4_include([../config/tls.m4])
Index: libgfortran/intrinsics/eoshift2.c
===================================================================
--- libgfortran/intrinsics/eoshift2.c	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libgfortran/intrinsics/eoshift2.c	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -77,6 +77,12 @@
 
       ret->offset = 0;
       ret->dtype = array->dtype;
+
+      if (arraysize > 0)
+	ret->data = internal_malloc_size (size * arraysize);
+      else
+	ret->data = internal_malloc_size (1);
+
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
         {
 	  index_type ub, str;
@@ -90,12 +96,6 @@
 	      * GFC_DESCRIPTOR_STRIDE(ret,i-1);
 
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
-
-	  if (arraysize > 0)
-	    ret->data = internal_malloc_size (size * arraysize);
-	  else
-	    ret->data = internal_malloc_size (1);
-
         }
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/ChangeLog
===================================================================
--- libgfortran/ChangeLog	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libgfortran/ChangeLog	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,3 +1,9 @@
+2012-05-12  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/53310
+	* intrinsics/eoshift2.c (eoshift2): Do not leak
+	memory by allocating it in the loop.
+
 2012-03-01  Release Manager
 
 	* GCC 4.6.3 released.
Index: boehm-gc/configure.ac
===================================================================
--- boehm-gc/configure.ac	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ boehm-gc/configure.ac	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -392,6 +392,7 @@
 oldLIBS="$LIBS"
 LIBS="$LIBS $THREADLIBS"
 AC_CHECK_FUNCS([pthread_getattr_np])
+AC_CHECK_FUNCS([pthread_get_stackaddr_np])
 LIBS="$oldLIBS"
 
 # Configuration of machine-dependent code
Index: boehm-gc/include/gc_config.h.in
===================================================================
--- boehm-gc/include/gc_config.h.in	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ boehm-gc/include/gc_config.h.in	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -87,6 +87,9 @@
 /* Define to 1 if you have the `pthread_getattr_np' function. */
 #undef HAVE_PTHREAD_GETATTR_NP
 
+/* Define to 1 if you have the `pthread_get_stackaddr_np_np' function. */
+#undef HAVE_PTHREAD_GET_STACKADDR_NP
+
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
Index: boehm-gc/include/private/gcconfig.h
===================================================================
--- boehm-gc/include/private/gcconfig.h	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ boehm-gc/include/private/gcconfig.h	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1331,7 +1331,11 @@
 	 These aren't used when dyld support is enabled (it is by default) */
 #     define DATASTART ((ptr_t) get_etext())
 #     define DATAEND	((ptr_t) get_end())
-#     define STACKBOTTOM ((ptr_t) 0xc0000000)
+#     ifdef HAVE_PTHREAD_GET_STACKADDR_NP
+#       define STACKBOTTOM (ptr_t)pthread_get_stackaddr_np(pthread_self())
+#     else
+#       define STACKBOTTOM ((ptr_t) 0xc0000000)
+#     endif
 #     define USE_MMAP
 #     define USE_MMAP_ANON
 #     define USE_ASM_PUSH_REGS
@@ -2011,7 +2015,11 @@
 	 These aren't used when dyld support is enabled (it is by default) */
 #     define DATASTART ((ptr_t) get_etext())
 #     define DATAEND	((ptr_t) get_end())
-#     define STACKBOTTOM ((ptr_t) 0x7fff5fc00000)
+#     ifdef HAVE_PTHREAD_GET_STACKADDR_NP
+#       define STACKBOTTOM (ptr_t)pthread_get_stackaddr_np(pthread_self())
+#     else
+#       define STACKBOTTOM ((ptr_t) 0x7fff5fc00000)
+#     endif
 #     define USE_MMAP
 #     define USE_MMAP_ANON
 #     ifdef GC_DARWIN_THREADS
Index: boehm-gc/ChangeLog
===================================================================
--- boehm-gc/ChangeLog	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ boehm-gc/ChangeLog	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,3 +1,17 @@
+2012-03-02  Jack Howarth  <howarth@bromo.med.uc.edu>
+
+	Backport from mainline
+	2012-02-23  Patrick Marlier  <patrick.marlier@gmail.com>
+		    Jack Howarth  <howarth@bromo.med.uc.edu>
+
+	PR boehm-gc/52179
+	* include/gc_config.h.in: Undefine HAVE_PTHREAD_GET_STACKADDR_NP.
+	* include/private/gcconfig.h (DARWIN): Define STACKBOTTOM with
+	pthread_get_stackaddr_np when available.
+	* configure.ac (THREADS): Check availability of
+	pthread_get_stackaddr_np.
+	* configure: Regenerate.
+
 2012-03-01  Release Manager
 
 	* GCC 4.6.3 released.
Index: boehm-gc/configure
===================================================================
--- boehm-gc/configure	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ boehm-gc/configure	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -15246,6 +15246,17 @@
 fi
 done
 
+for ac_func in pthread_get_stackaddr_np
+do :
+  ac_fn_c_check_func "$LINENO" "pthread_get_stackaddr_np" "ac_cv_func_pthread_get_stackaddr_np"
+if test "x$ac_cv_func_pthread_get_stackaddr_np" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_PTHREAD_GET_STACKADDR_NP 1
+_ACEOF
+
+fi
+done
+
 LIBS="$oldLIBS"
 
 # Configuration of machine-dependent code
Index: libffi/src/powerpc/aix.S
===================================================================
--- libffi/src/powerpc/aix.S	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libffi/src/powerpc/aix.S	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,5 +1,5 @@
 /* -----------------------------------------------------------------------
-   aix.S - Copyright (c) 2002,2009 Free Software Foundation, Inc.
+   aix.S - Copyright (c) 2002, 2009 Free Software Foundation, Inc.
    based on darwin.S by John Hornkvist
 
    PowerPC Assembly glue.
@@ -79,6 +79,8 @@
 	.set f20,20
 	.set f21,21
 
+	.extern .ffi_prep_args
+
 #define LIBFFI_ASM
 #include <fficonfig.h>
 #include <ffi.h>
@@ -125,6 +127,7 @@
 	/* Call ffi_prep_args.  */
 	mr	r4, r1
 	bl	.ffi_prep_args
+	nop
 
 	/* Now do the call.  */
 	ld	r0, 0(r29)
@@ -226,6 +229,7 @@
 	/* Call ffi_prep_args.  */
 	mr	r4, r1
 	bl	.ffi_prep_args
+	nop
 
 	/* Now do the call.  */
 	lwz	r0, 0(r29)
Index: libffi/src/powerpc/aix_closure.S
===================================================================
--- libffi/src/powerpc/aix_closure.S	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libffi/src/powerpc/aix_closure.S	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -79,6 +79,8 @@
 	.set f20,20
 	.set f21,21
 
+	.extern .ffi_closure_helper_DARWIN
+
 #define LIBFFI_ASM
 #define JUMPTARGET(name) name
 #define L(x) x
@@ -165,6 +167,7 @@
 
 	/* look up the proper starting point in table  */
 	/* by using return type as offset */
+	lhz	r3, 10(r3)	/* load type from return type */
 	ld	r4, LC..60(2)	/* get address of jump table */
 	sldi	r3, r3, 4	/* now multiply return type by 16 */
 	ld	r0, 240+16(r1)	/* load return address */
@@ -337,8 +340,9 @@
 
 	/* look up the proper starting point in table  */
 	/* by using return type as offset */
+	lhz	r3, 6(r3)	/* load type from return type */
 	lwz	r4, LC..60(2)	/* get address of jump table */
-	slwi	r3, r3, 4	/* now multiply return type by 4 */
+	slwi	r3, r3, 4	/* now multiply return type by 16 */
 	lwz	r0, 176+8(r1)	/* load return address */
 	add	r3, r3, r4	/* add contents of table to table address */
 	mtctr	r3
Index: libffi/ChangeLog
===================================================================
--- libffi/ChangeLog	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libffi/ChangeLog	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,3 +1,17 @@
+2012-03-22  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backport from mainline:
+	2012-03-09  David Edelsohn  <dje.gcc@gmail.com>
+
+	* src/powerpc/aix_closure.S (ffi_closure_ASM): Adjust for Darwin64
+	change to return value of ffi_closure_helper_DARWIN and load type
+	from return type.
+
+	From Tom Honermann <tom.honermann@oracle.com>:
+	* src/powerpc/aix.S: Declare .ffi_prep_args.  Insert nops after
+	branch instructions.
+	* src/powerpc/aix_closure.S: Declare .ffi_closure_helper_DARWIN.
+
 2012-03-01  Release Manager
 
 	* GCC 4.6.3 released.
Index: libjava/configure.ac
===================================================================
--- libjava/configure.ac	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libjava/configure.ac	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -886,14 +886,9 @@
         SYSTEMSPEC="-lunicows $SYSTEMSPEC"
       fi
     ;;
-    *-*-darwin9*)
+    *-*-darwin[[912]]*)
       SYSTEMSPEC="%{!Zdynamiclib:%{!Zbundle:-allow_stack_execute}}"
     ;;
-    *-*-darwin[[12]]*)
-      # Something is incompatible with pie, would be nice to fix it and
-      # remove -no_pie.  PR49461
-      SYSTEMSPEC="-no_pie %{!Zdynamiclib:%{!Zbundle:-allow_stack_execute}}"
-    ;;
     *)
       SYSTEMSPEC=
     ;;
Index: libjava/ChangeLog
===================================================================
--- libjava/ChangeLog	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libjava/ChangeLog	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -1,3 +1,13 @@
+2012-03-02  Jack Howarth  <howarth@bromo.med.uc.edu>
+
+	Backport from mainline
+	2012-02-23  Patrick Marlier  <patrick.marlier@gmail.com>
+       	    Jack Howarth  <howarth@bromo.med.uc.edu>
+
+	PR target/49461
+	* configure.ac (SYSTEMSPEC): No longer pass -no_pie for darwin11.
+	* configure: Regenerate.
+
 2012-03-01  Release Manager
 
 	* GCC 4.6.3 released.
Index: libjava/configure
===================================================================
--- libjava/configure	(.../tags/gcc_4_6_3_release)	(revision 190226)
+++ libjava/configure	(.../branches/gcc-4_6-branch)	(revision 190226)
@@ -19775,14 +19775,9 @@
         SYSTEMSPEC="-lunicows $SYSTEMSPEC"
       fi
     ;;
-    *-*-darwin9*)
+    *-*-darwin[912]*)
       SYSTEMSPEC="%{!Zdynamiclib:%{!Zbundle:-allow_stack_execute}}"
     ;;
-    *-*-darwin[12]*)
-      # Something is incompatible with pie, would be nice to fix it and
-      # remove -no_pie.  PR49461
-      SYSTEMSPEC="-no_pie %{!Zdynamiclib:%{!Zbundle:-allow_stack_execute}}"
-    ;;
     *)
       SYSTEMSPEC=
     ;;
